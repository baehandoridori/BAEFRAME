# 협업 경험 개선 계획

> 실시간 협업의 버벅거림과 비효율적인 프로세스 개선

---

## 요약

| 항목 | 수정 파일 | 이유 | 우선순위 | 상태 |
|------|----------|------|---------|------|
| 옵션 A: LAN P2P 동기화 | collaboration-manager.js, lan-discovery.js (신규) | 같은 네트워크에서 즉시 동기화 | 높음 | ⬜ 대기 |
| 옵션 B: CRDT(Yjs) 도입 | schema.js, review-data-manager.js, comment-manager.js | 충돌 없는 병합, 오프라인 지원 | 중간 | ⬜ 대기 |
| 옵션 C: 폴링 최적화 | collaboration-manager.js | 즉시 적용 가능한 개선 | 높음 | ⬜ 대기 |
| 옵션 D: Google Drive Push (웹 뷰어) | web-viewer 관련 | 웹에서 실시간 알림 | 낮음 | ⬜ 대기 |

---

## 배경 및 목적

### 현재 문제점

사용자 피드백:
- 공유드라이브 환경에서 실시간 협업이 **버벅거림**
- 매번 콜랩 파일을 열고 확인하는 프로세스가 **비효율적**
- **나쁜 사용자 경험** 제공

### 기술적 근본 원인

| 원인 | 설명 | 영향도 |
|------|------|--------|
| Google Drive 동기화 지연 | 클라우드 특성상 수초~수십초 지연 발생 | **높음** |
| 폴링 방식 | 5~10초 간격으로 파일 확인 → 실시간이 아님 | **높음** |
| 파일 기반 Presence | `.collab` 파일 I/O 오버헤드 | 중간 |
| 네트워크 의존성 | 인터넷 속도/안정성에 따라 성능 편차 큼 | 중간 |

### 현재 구현 상태 (collaboration-manager.js)

```javascript
// 현재 설정값
const PRESENCE_UPDATE_INTERVAL = 10000;   // 10초마다 presence 업데이트
const SYNC_INTERVAL_COLLAB = 5000;        // 협업자 있을 때: 5초
const SYNC_INTERVAL_ACTIVE = 3000;        // 활발한 편집 시: 3초
const PRESENCE_TIMEOUT = 45000;           // 45초 동안 업데이트 없으면 오프라인
```

**문제**: 최선의 경우에도 **3~5초 지연** + **Google Drive 동기화 지연** 발생

---

## 옵션 A: LAN P2P 동기화 (권장)

### 개요

같은 네트워크(사무실)에 있는 사용자끼리는 **mDNS로 자동 발견**하고 **WebRTC P2P로 즉시 동기화**합니다.
서로 다른 네트워크에서는 기존 Google Drive 방식으로 폴백합니다.

### 작동 원리

```
[같은 LAN에서]
1. 앱 시작 시 mDNS로 "BAEFRAME" 서비스 브로드캐스트
2. 같은 .bframe 파일을 열고 있는 다른 피어 발견
3. WebRTC DataChannel로 P2P 연결
4. 변경 사항 즉시 전송 (ms 단위)

[다른 네트워크에서]
1. LAN에서 피어를 찾지 못함
2. 기존 Google Drive 기반 동기화로 폴백
3. 현재와 동일하게 동작
```

### 기대 효과

| 시나리오 | 현재 | 개선 후 |
|---------|------|--------|
| 같은 사무실 협업 | 3~10초 + Drive 지연 | **< 100ms** |
| 원격 협업 (다른 네트워크) | 3~10초 + Drive 지연 | 3~10초 + Drive 지연 (동일) |

### 구현 계획

#### Phase A-1: mDNS 피어 발견
- `mdns` 또는 `bonjour` npm 패키지 사용
- Windows 10/11 네이티브 mDNS 지원 활용
- 서비스명: `_baeframe._tcp.local`
- TXT 레코드에 열고 있는 파일 해시 포함

**수정 파일:**
- `renderer/scripts/modules/lan-discovery.js` (신규)
- `main/ipc-handlers.js` (mDNS IPC 추가)
- `preload/preload.js` (API 노출)

#### Phase A-2: WebRTC P2P 연결
- 시그널링: mDNS TXT 레코드 또는 .collab 파일 활용
- 같은 LAN이면 STUN 서버 불필요
- DataChannel로 JSON 메시지 교환

**수정 파일:**
- `renderer/scripts/modules/p2p-sync.js` (신규)
- `collaboration-manager.js` (P2P 통합)

#### Phase A-3: 하이브리드 동기화 전략
- LAN 피어 있으면 P2P 우선
- P2P 실패 시 Google Drive 폴백
- 두 방식 동시 사용 가능 (LAN + WAN 사용자 혼재)

**수정 파일:**
- `collaboration-manager.js`
- `review-data-manager.js`

### 기술 스택

```javascript
// package.json에 추가
{
  "dependencies": {
    "mdns": "^2.7.2",        // 또는 "@phnq/bonjour"
    // WebRTC는 Electron/Chromium 내장
  },
  "devDependencies": {
    "electron-rebuild": "^3.6.0"  // 네이티브 모듈 리빌드
  }
}
```

### 리스크

| 리스크 | 심각도 | 완화 방안 |
|--------|--------|----------|
| mDNS가 막힌 네트워크 | 중간 | Google Drive 폴백으로 동작 보장 |
| 네이티브 모듈 빌드 실패 | 높음 | electron-rebuild 사용, 순수 JS 폴백 구현 |
| Windows 방화벽 차단 | 중간 | 설치 시 방화벽 규칙 자동 추가 |
| VLAN 분리된 환경 | 낮음 | Google Drive 폴백 |

---

## 옵션 B: CRDT (Yjs) 도입

### 개요

데이터 구조를 [Yjs](https://docs.yjs.dev/) CRDT로 변환하여 **충돌 없는 자동 병합**을 구현합니다.

### 장점

- **충돌 해결 불필요**: CRDT 특성상 항상 일관된 상태로 수렴
- **오프라인 완벽 지원**: 로컬에서 변경 후 나중에 동기화
- **중앙 서버 불필요**: P2P 또는 파일 기반 동기화 가능

### 단점

- **.bframe 형식 변경**: 하위 호환성 문제
- **대규모 리팩토링 필요**: comment-manager, drawing-manager 등 전면 수정
- **학습 곡선**: CRDT 개념 이해 필요

### 구현 계획

#### Phase B-1: Yjs 스키마 설계
```javascript
// Y.Doc 구조
const ydoc = new Y.Doc();

const comments = ydoc.getMap('comments');
// comments.get('layerId').get('markerId') → Y.Map

const drawings = ydoc.getMap('drawings');
// drawings.get('layerId').get('frame') → Y.Array
```

#### Phase B-2: 기존 데이터 마이그레이션
- `.bframe` v2.0 → v3.0 (Yjs 기반)
- 자동 마이그레이션 + 백업

#### Phase B-3: 동기화 Provider 구현
- `y-indexeddb`: 로컬 저장
- 파일 기반 동기화: `.bframe` 파일로 인코딩/디코딩
- WebRTC Provider (옵션 A와 결합 가능)

### 기술 스택

```javascript
{
  "dependencies": {
    "yjs": "^13.6.0",
    "y-indexeddb": "^9.0.0",
    "lib0": "^0.2.0"
  }
}
```

### 추정 작업량

| 항목 | 난이도 | 영향 범위 |
|------|--------|----------|
| 스키마 설계 | 중간 | schema.js |
| CommentManager CRDT 변환 | 높음 | comment-manager.js (897줄) |
| DrawingManager CRDT 변환 | 높음 | drawing-manager.js |
| ReviewDataManager 통합 | 높음 | review-data-manager.js (804줄) |
| 마이그레이션 | 중간 | schema.js |
| 테스트 | 높음 | 전체 |

**결론**: 중장기 로드맵으로 적합, 즉각적인 개선에는 부적합

---

## 옵션 C: 폴링 최적화 (즉시 적용 가능)

### 개요

현재 아키텍처를 유지하면서 **동기화 효율을 최대화**합니다.

### 개선 항목

#### C-1: 파일 변경 감지 즉시 동기화

현재 `fs.watch`가 구현되어 있지만 활용도가 낮습니다.

```javascript
// 현재: 변경 감지 시 단순 이벤트 발생
// 개선: 변경 감지 시 즉시 동기화 트리거

// collaboration-manager.js
_onFileChanged(filePath) {
  // Google Drive 동기화 완료 시점에 즉시 반영
  if (filePath === this.bframePath) {
    this._performSync();  // 폴링 타이머와 별개로 즉시 실행
  }
}
```

#### C-2: 더 공격적인 폴링 간격

```javascript
// 현재
const SYNC_INTERVAL_ACTIVE = 3000;        // 3초

// 개선 (협업 감지 시)
const SYNC_INTERVAL_ACTIVE = 1500;        // 1.5초
const SYNC_INTERVAL_COLLAB = 3000;        // 3초 (기존 5초)
```

#### C-3: 델타 동기화 (변경분만 전송)

현재 전체 파일을 매번 로드/저장합니다.

```javascript
// 개선: 변경된 마커만 전송
// 1. 저장 시 변경 목록 추적
// 2. 동기화 시 변경분만 머지
// 3. 파일 쓰기는 배치로 묶기
```

#### C-4: Presence 업데이트 최적화

```javascript
// 현재: 10초마다 .collab 파일 읽기/쓰기
// 개선: 변경 시에만 업데이트 + heartbeat 분리
```

### 기대 효과

| 시나리오 | 현재 | 개선 후 |
|---------|------|--------|
| 협업 시 최소 지연 | ~3초 | **~1.5초** |
| 파일 변경 감지 후 | 다음 폴링까지 대기 | **즉시 반영** |
| I/O 부하 | 높음 | 중간 (델타 동기화) |

### 수정 파일

- `collaboration-manager.js` (폴링 간격, 파일 감지 연동)
- `review-data-manager.js` (델타 동기화)

---

## 옵션 D: Google Drive Push API (웹 뷰어 전용)

### 개요

[Google Drive Push Notifications](https://developers.google.com/workspace/drive/api/guides/push)를 사용하여 파일 변경 시 웹훅으로 알림을 받습니다.

### 한계

| 항목 | 설명 |
|------|------|
| 서버 필요 | HTTPS 웹훅 수신 서버 필요 (Vercel Functions 등) |
| Desktop 앱 불가 | Electron 앱에서 직접 웹훅 수신 불가 |
| 웹 뷰어에만 적용 가능 | baeframe.vercel.app |

### 구현 방법

```
[파일 변경]
   ↓
[Google Drive Push → Vercel Function]
   ↓
[WebSocket/SSE → 웹 뷰어 클라이언트]
   ↓
[데이터 리로드]
```

### 결론

- **Desktop 앱**에는 적용 불가
- **웹 뷰어** 2단계 개발 시 고려 가능

---

## 권장 전략

### 단기 (즉시 적용)

**옵션 C: 폴링 최적화** 먼저 적용

- 구현 난이도 낮음
- 기존 아키텍처 유지
- 모든 환경에서 개선 효과

### 중기 (1~2개월)

**옵션 A: LAN P2P 동기화** 구현

- 같은 사무실 협업 경험 대폭 개선
- Google Drive 폴백으로 안정성 보장
- 네이티브 모듈 의존성 주의

### 장기 (3개월+)

**옵션 B: CRDT 도입** 검토

- 충돌 해결 근본적 해결
- 오프라인 완벽 지원
- 대규모 리팩토링 필요

---

## 구현 우선순위 결정 기준

| 기준 | 가중치 | 설명 |
|------|--------|------|
| 사용자 체감 개선 | 높음 | 버벅거림/지연 해소 |
| 구현 난이도 | 중간 | 기존 코드 영향 최소화 |
| 안정성 | 높음 | 기존 기능 유지 |
| 유지보수성 | 중간 | 코드 복잡도 관리 |

---

## 결정 필요 사항

1. **사무실 환경 분석**: 팀원들이 주로 같은 네트워크에서 협업하는지?
2. **네트워크 구성**: VLAN 분리, 방화벽 정책 등
3. **우선순위**: 즉각적인 개선 vs 근본적인 해결
4. **리소스**: 네이티브 모듈 빌드 환경 구축 가능 여부

---

## 참고 자료

### 기술 문서

- [Yjs Documentation](https://docs.yjs.dev/) - CRDT 라이브러리
- [Local, first, forever](https://tonsky.me/blog/crdt-filesync/) - CRDT + 파일 동기화 전략
- [Building Offline-First Collaborative Editors](https://dev.to/hexshift/building-offline-first-collaborative-editors-with-crdts-and-indexeddb-no-backend-needed-4p7l) - CRDTs + IndexedDB 가이드
- [crdt-over-fs](https://github.com/3timeslazy/crdt-over-fs) - 파일 시스템 기반 CRDT 실험
- [Multicast Service Discovery in Electron](http://jbavari.github.io/blog/2016/12/29/multicast-service-discovery-in-electron/) - Electron mDNS 구현
- [P2P Peer Discovery](https://jsantell.com/p2p-peer-discovery/) - mDNS, DHT 등 피어 발견 기법
- [WebRTC without Signaling Server](https://dev.to/hexshift/building-a-minimal-webrtc-peer-without-a-signaling-server-using-only-manual-sdp-exchange-mck) - 서버 없는 WebRTC
- [Google Drive Push Notifications](https://developers.google.com/workspace/drive/api/guides/push) - Drive API 웹훅

### 관련 프로젝트 문서

- `DEVLOG/실시간-협업-동기화-구현-계획.md` - 현재 협업 기능 상세 설계
- `BAEFRAME-WEB-VIEWER.md` - 웹 뷰어 개발 계획
- `baeframe-dev-docs.md` - 전체 아키텍처 문서

---

## 다음 단계

1. [ ] 팀 환경 분석 (네트워크 구성, 협업 패턴)
2. [ ] 옵션 C (폴링 최적화) 즉시 적용 검토
3. [ ] 옵션 A (LAN P2P) PoC 구현
4. [ ] 사용자 피드백 수집 및 개선 방향 결정
