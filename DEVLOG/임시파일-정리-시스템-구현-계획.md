# 임시 파일 정리 시스템 구현 계획

## 요약

| 항목 | 수정 파일 | 이유 | 우선순위 | 상태 |
|------|----------|------|---------|------|
| Phase 1 | preload.js, ipc-handlers.js | 누락된 파일 API 추가 (copyFile, deleteFile, scanTempFiles) | 높음 | ⬜ 대기 |
| Phase 2 | file-cleanup-manager.js (신규) | 파일 정리 매니저 모듈 생성 | 높음 | ⬜ 대기 |
| Phase 3 | review-data-manager.js | 마이그레이션 후 백업 자동 삭제 로직 연결 | 중간 | ⬜ 대기 |
| Phase 4 | settings.html, settings.js | 설정 UI에 정리 옵션 추가 | 중간 | ⬜ 대기 |
| Phase 5 | main.js | 앱 시작 시 자동 정리 훅 | 낮음 | ⬜ 대기 |

---

## 배경 및 목적

### 현재 문제점

BAEFRAME은 작업 중 다양한 임시/백업 파일을 생성합니다:

| 파일 유형 | 확장자 | 생성 시점 | 현재 정리 방식 |
|----------|--------|----------|---------------|
| 리뷰 데이터 | `.bframe` | 영상 로드 시 | 없음 (핵심 데이터) |
| 마이그레이션 백업 | `.bframe.bak` | v1→v2 마이그레이션 시 | ❌ 미구현 (코드 있으나 미호출) |
| 협업 파일 | `.bframe.collab` | 협업 세션 시작 시 | ✅ 타임아웃 시 자동 정리 |
| 손상 파일 | `.bframe.corrupted` | JSON 복구 시 | ❌ 없음 |

**핵심 문제:**
1. `_deleteBackup()` 메서드가 정의되었으나 **어디에서도 호출되지 않음**
2. `copyFile`, `deleteFile` API가 **preload.js에 노출되지 않음**
3. 오래된 백업/손상 파일이 **영구 축적**됨
4. 사용자가 임시 파일을 **수동 정리할 방법 없음**

### 해결 목표

1. 마이그레이션 성공 후 `.bak` 파일 자동 삭제
2. 설정에서 임시 파일 일괄 정리 기능 제공
3. 오래된 파일 자동 정리 (retention policy)
4. 프로젝트 폴더별 정리 지원

---

## 유사 서비스 사례 연구

### Adobe Premiere Pro
- **Autosave 폴더 분리**: 프로젝트 폴더 내 `Adobe Premiere Pro Auto-Save/` 하위 폴더
- **보관 개수 제한**: 최근 N개만 유지 (기본 20개)
- **설정 가능**: 저장 간격, 보관 개수, 저장 위치 모두 설정 가능

### Figma
- **IndexedDB 기반**: 로컬 캐시는 브라우저 스토리지에 저장
- **버전 히스토리 통합**: 자동 저장이 버전 히스토리에 체크포인트로 기록
- **캐시 클리어 기능**: 설정에서 명시적으로 캐시 삭제 가능

### 일반적인 모범 사례
- **Retention Policy**: 생성 시간 기준 자동 삭제 (7일, 30일 등)
- **개수 제한**: 최근 N개만 보관
- **앱 시작 시 정리**: 오래된 임시 파일 자동 검사 및 삭제
- **수동 정리 옵션**: 사용자가 명시적으로 정리할 수 있는 UI

---

## Phase 1: 누락된 파일 API 추가

### 목표
`copyFile`, `deleteFile`, `scanTempFiles` API를 IPC와 preload에 추가

### 수정 파일
- `main/ipc-handlers.js`
- `preload/preload.js`

### 구현 내용

#### ipc-handlers.js에 추가할 핸들러
```javascript
// 파일 복사
ipcMain.handle('file:copy', async (event, srcPath, destPath) => {
  validateFilePath(srcPath, ['.bframe', '.json', '.bak']);
  validateFilePath(destPath, ['.bframe', '.json', '.bak']);
  await fs.promises.copyFile(srcPath, destPath);
  return true;
});

// 파일 삭제
ipcMain.handle('file:delete', async (event, filePath) => {
  validateFilePath(filePath, ['.bak', '.corrupted', '.collab']);
  await fs.promises.unlink(filePath);
  return true;
});

// 임시 파일 스캔 (특정 폴더 내)
ipcMain.handle('file:scan-temp-files', async (event, folderPath) => {
  const files = await fs.promises.readdir(folderPath);
  const tempFiles = files.filter(f =>
    f.endsWith('.bak') ||
    f.endsWith('.corrupted') ||
    f.endsWith('.collab')
  );

  const result = await Promise.all(tempFiles.map(async (file) => {
    const fullPath = path.join(folderPath, file);
    const stats = await fs.promises.stat(fullPath);
    return {
      path: fullPath,
      name: file,
      type: file.split('.').pop(),
      size: stats.size,
      createdAt: stats.birthtime,
      modifiedAt: stats.mtime
    };
  }));

  return result;
});
```

#### preload.js에 추가할 API
```javascript
copyFile: (srcPath, destPath) => ipcRenderer.invoke('file:copy', srcPath, destPath),
deleteFile: (filePath) => ipcRenderer.invoke('file:delete', filePath),
scanTempFiles: (folderPath) => ipcRenderer.invoke('file:scan-temp-files', folderPath),
```

### 예상 리스크
- **보안**: 임의 파일 삭제 방지를 위해 확장자 화이트리스트 필수
- **동시성**: 파일 사용 중 삭제 시도 시 에러 → try-catch 처리

---

## Phase 2: FileCleanupManager 모듈 생성

### 목표
임시 파일 정리를 위한 전용 매니저 클래스 생성

### 수정 파일
- `renderer/scripts/modules/file-cleanup-manager.js` (신규)

### 구현 내용

```javascript
/**
 * 파일 정리 매니저
 * 임시 파일(.bak, .corrupted, .collab) 정리 담당
 */
class FileCleanupManager {
  constructor() {
    // 기본 설정
    this.settings = {
      autoCleanupEnabled: true,
      retentionDays: 7,           // 7일 이상 된 백업 자동 삭제
      maxBackupCount: 5,          // 파일당 최대 백업 수
      cleanupOnStartup: true,     // 앱 시작 시 자동 정리
      cleanupTargets: ['bak', 'corrupted']  // collab은 협업 매니저가 관리
    };
  }

  /**
   * 폴더 내 임시 파일 스캔
   * @param {string} folderPath - 스캔할 폴더 경로
   * @returns {Promise<TempFileInfo[]>}
   */
  async scanFolder(folderPath) { ... }

  /**
   * Retention policy 기반 자동 정리
   * @param {string} folderPath - 정리할 폴더
   * @returns {Promise<CleanupResult>}
   */
  async autoCleanup(folderPath) { ... }

  /**
   * 특정 .bframe 파일의 모든 임시 파일 삭제
   * @param {string} bframePath - .bframe 파일 경로
   */
  async cleanupForFile(bframePath) { ... }

  /**
   * 전체 통계 조회
   * @param {string[]} folderPaths - 조회할 폴더들
   */
  async getStats(folderPaths) { ... }
}
```

### 핵심 기능

#### 1. Retention Policy (보관 기간)
```javascript
async autoCleanup(folderPath) {
  const files = await this.scanFolder(folderPath);
  const now = Date.now();
  const retentionMs = this.settings.retentionDays * 24 * 60 * 60 * 1000;

  const toDelete = files.filter(f => {
    const age = now - new Date(f.createdAt).getTime();
    return age > retentionMs;
  });

  // 삭제 실행
  for (const file of toDelete) {
    await window.electronAPI.deleteFile(file.path);
  }

  return { deleted: toDelete.length, freed: toDelete.reduce((s, f) => s + f.size, 0) };
}
```

#### 2. 파일별 백업 개수 제한
```javascript
async enforceBackupLimit(bframePath) {
  const backups = await this._getBackupsForFile(bframePath);

  if (backups.length > this.settings.maxBackupCount) {
    // 오래된 순으로 정렬 후 초과분 삭제
    backups.sort((a, b) => new Date(a.createdAt) - new Date(b.createdAt));
    const toDelete = backups.slice(0, backups.length - this.settings.maxBackupCount);

    for (const backup of toDelete) {
      await window.electronAPI.deleteFile(backup.path);
    }
  }
}
```

### 예상 리스크
- **데이터 손실**: 실수로 중요 파일 삭제 방지 → `.bframe` 파일은 절대 삭제 대상 제외
- **권한 문제**: Google Drive 동기화 폴더 파일 삭제 지연 가능 → 재시도 로직 필요

---

## Phase 3: 마이그레이션 후 백업 자동 삭제 연결

### 목표
마이그레이션 성공 후 `_deleteBackup()` 호출하여 `.bak` 파일 자동 삭제

### 수정 파일
- `renderer/scripts/modules/review-data-manager.js`

### 구현 내용

현재 코드 (`load()` 메서드 내):
```javascript
// 마이그레이션 필요 시
if (needsMigration(data)) {
  await this._createBackup();
  migratedData = migrateToV2(data);
  await this.save();  // 마이그레이션된 데이터 저장
  // ❌ 여기서 _deleteBackup() 호출 누락!
}
```

수정 후:
```javascript
if (needsMigration(data)) {
  await this._createBackup();
  migratedData = migrateToV2(data);
  await this.save();

  // ✅ 마이그레이션 성공 후 백업 삭제 (설정에 따라)
  if (this.cleanupManager?.settings.autoDeleteAfterMigration) {
    await this._deleteBackup();
    log.info('마이그레이션 완료 후 백업 삭제됨');
  }
}
```

### 예상 리스크
- **복구 불가**: 마이그레이션 후 문제 발견 시 롤백 불가
- **완화책**: 설정에서 "마이그레이션 후 백업 유지" 옵션 제공 (기본: 7일 후 삭제)

---

## Phase 4: 설정 UI에 정리 옵션 추가

### 목표
사용자가 임시 파일을 확인하고 정리할 수 있는 UI 제공

### 수정 파일
- `renderer/settings.html`
- `renderer/scripts/settings.js`

### UI 설계

```
┌─────────────────────────────────────────────────────┐
│ 파일 정리                                            │
├─────────────────────────────────────────────────────┤
│                                                     │
│ 자동 정리                                           │
│ ┌─────────────────────────────────────────────────┐ │
│ │ [✓] 앱 시작 시 오래된 임시 파일 자동 정리        │ │
│ │     보관 기간: [7일 ▼]                          │ │
│ │                                                 │ │
│ │ [✓] 마이그레이션 후 백업 파일 자동 삭제          │ │
│ └─────────────────────────────────────────────────┘ │
│                                                     │
│ 현재 임시 파일                                       │
│ ┌─────────────────────────────────────────────────┐ │
│ │ 백업 파일 (.bak)      : 15개 (24.5 MB)          │ │
│ │ 손상 파일 (.corrupted): 2개  (1.2 MB)           │ │
│ │ 협업 파일 (.collab)   : 3개  (12 KB)            │ │
│ │ ─────────────────────────────────────────────── │ │
│ │ 총합                  : 20개 (25.7 MB)          │ │
│ └─────────────────────────────────────────────────┘ │
│                                                     │
│ [ 상세 보기 ]  [ 선택 삭제 ]  [ 전체 정리 ]          │
│                                                     │
│ 캐시 정리                                           │
│ ┌─────────────────────────────────────────────────┐ │
│ │ 썸네일 캐시: 156 MB  [ 삭제 ]                   │ │
│ │ FFmpeg 캐시: 2.3 GB  [ 삭제 ]                   │ │
│ └─────────────────────────────────────────────────┘ │
│                                                     │
└─────────────────────────────────────────────────────┘
```

### 상세 보기 모달

```
┌────────────────────────────────────────────────────────────┐
│ 임시 파일 목록                                        [ X ] │
├────────────────────────────────────────────────────────────┤
│ 필터: [전체 ▼]  정렬: [날짜순 ▼]                           │
├────────────────────────────────────────────────────────────┤
│ [✓] shot_001_v2.bframe.bak      │ 1.2 MB │ 2026-01-20    │
│ [✓] shot_001_v1.bframe.bak      │ 0.8 MB │ 2026-01-15    │
│ [ ] scene_02.bframe.corrupted   │ 2.1 MB │ 2026-01-25    │
│ [✓] intro.bframe.collab         │ 4 KB   │ 2026-01-26    │
│ ...                                                        │
├────────────────────────────────────────────────────────────┤
│ 선택: 3개 (2.0 MB)                    [ 선택 항목 삭제 ]    │
└────────────────────────────────────────────────────────────┘
```

### 예상 리스크
- **UX 복잡성**: 일반 사용자에게 불필요한 기능 노출 → "고급 설정" 섹션에 배치
- **실수 삭제**: 확인 다이얼로그 필수

---

## Phase 5: 앱 시작 시 자동 정리 훅

### 목표
앱 시작 시 오래된 임시 파일 자동 검사 및 정리

### 수정 파일
- `renderer/scripts/app.js` (또는 `main.js`)

### 구현 내용

```javascript
// app.js 초기화 시
async function initializeApp() {
  // ... 기존 초기화 코드 ...

  // 자동 정리 실행 (설정이 활성화된 경우)
  const settings = await window.electronAPI.loadSettings();
  if (settings.cleanup?.cleanupOnStartup) {
    const recentFolders = settings.recentFolders || [];

    for (const folder of recentFolders) {
      try {
        const result = await fileCleanupManager.autoCleanup(folder);
        if (result.deleted > 0) {
          log.info(`자동 정리 완료: ${folder}`, result);
        }
      } catch (error) {
        log.warn(`자동 정리 실패: ${folder}`, error);
      }
    }
  }
}
```

### 성능 고려사항
- **비동기 실행**: UI 블로킹 방지
- **최근 폴더만**: 모든 폴더 스캔 대신 최근 작업 폴더만 대상
- **백그라운드**: 앱 시작 후 약간의 지연 후 실행

---

## 리스크 및 우려 사항

| 리스크 | 심각도 | 완화 방안 |
|--------|--------|----------|
| 중요 백업 실수 삭제 | 높음 | `.bframe` 파일은 삭제 대상에서 절대 제외, 확인 다이얼로그 |
| Google Drive 동기화 충돌 | 중간 | 재시도 로직, 충돌 시 사용자 알림 |
| 권한 부족으로 삭제 실패 | 낮음 | try-catch 처리, 실패 시 로그 기록 |
| 협업 중 collab 파일 삭제 | 중간 | collab 파일은 협업 매니저가 관리, 자동 정리 대상 제외 옵션 |

---

## 테스트 방법

### 단위 테스트
1. `file:delete` IPC 핸들러 - 허용/비허용 확장자 테스트
2. `FileCleanupManager.autoCleanup()` - retention policy 동작 확인
3. `FileCleanupManager.enforceBackupLimit()` - 백업 개수 제한 확인

### 통합 테스트
1. 마이그레이션 → 백업 생성 → 저장 성공 → 백업 삭제 플로우
2. 설정 UI에서 "전체 정리" 클릭 → 파일 삭제 확인
3. 앱 시작 → 자동 정리 실행 → 로그 확인

### 수동 테스트
1. Google Drive 폴더에 `.bak` 파일 수동 생성 후 정리 기능 테스트
2. 협업 세션 중 `.collab` 파일 삭제 시도 (실패해야 함)
3. 대용량 파일 다수 삭제 시 성능 측정

---

## 구현 우선순위 정리

### 즉시 구현 (Quick Win)
1. **Phase 1**: `copyFile`, `deleteFile` API 추가 → 기존 코드가 동작하도록
2. **Phase 3**: `_deleteBackup()` 호출 연결 → 백업 축적 방지

### 중기 구현
3. **Phase 2**: FileCleanupManager → 체계적인 정리 시스템
4. **Phase 4**: 설정 UI → 사용자 제어 권한 부여

### 장기 구현
5. **Phase 5**: 앱 시작 시 자동 정리 → 완전 자동화

---

## 참고 자료

- [Figma 자동 저장 비하인드 스토리](https://www.figma.com/blog/behind-the-feature-autosave/)
- [Adobe Premiere Pro 자동 저장 설정](https://helpx.adobe.com/premiere/desktop/get-started/preferences-and-settings/auto-save-preferences.html)
- [Electron 앱 데이터 관리](https://medium.com/how-to-electron/how-to-reset-application-data-in-electron-48bba70b5a49)
- [임시 파일 관리 모범 사례](https://hivo.co/blog/mastering-temporary-file-management-minimizing-clutter-and-maximizing-efficiency)
