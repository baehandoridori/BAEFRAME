# BAEFRAME 코드 리뷰 검증 리포트

> 작성일: 2026-01-13
> 검토자: Claude (GPT 리뷰 내용 검증)

---

## 개요

GPT로부터 받은 코드 리뷰 결과를 실제 코드베이스와 대조하여 검증한 문서입니다.
각 항목의 **유효성**, **실제 위험도**, **일반인도 이해할 수 있는 설명**을 포함합니다.

---

## 검증 결과 요약

| 분류 | 전체 항목 | 유효 | 부분 유효 | 무효/과장 |
|------|----------|------|----------|----------|
| 에러 처리 & 안정성 | 7 | 4 | 3 | 0 |
| 성능 & 최적화 | 7 | 5 | 2 | 0 |
| 코드 품질 | 5 | 4 | 1 | 0 |
| Electron 보안 | 4 | 2 | 2 | 0 |
| 아키텍처 | 3 | 2 | 1 | 0 |
| **합계** | **26** | **17** | **9** | **0** |

---

## 1. 에러 처리 & 안정성

### 1.1 캔버스 크기 동기화 시 크래시 가능성

| 항목 | 내용 |
|------|------|
| **위치** | `renderer/scripts/modules/drawing-canvas.js:86-99` |
| **GPT 주장** | 캔버스가 0x0일 때 `getImageData(0,0,0,0)` 호출 시 예외 발생 가능 |
| **검증 결과** | **부분 유효** |
| **실제 위험도** | 낮음 |

**일반인 설명:**
> 그림판 캔버스 크기를 조절할 때, 크기가 0x0(아무것도 없는 상태)이면 기존 그림을 복사하려다 오류가 날 수 있습니다. 마치 아무것도 없는 빈 종이에서 복사하려는 것과 같습니다.

**실제 상황:**
- 현대 브라우저(Chromium 포함)에서는 0x0 캔버스에서 빈 ImageData를 반환
- Electron 환경에서 실제 크래시가 발생할 가능성은 낮음
- 그러나 방어 코드가 없으므로 **개선 권장**

---

### 1.2 Windows 파일 경로 URL 변환 문제

| 항목 | 내용 |
|------|------|
| **위치** | `renderer/scripts/modules/video-player.js:266-270` |
| **GPT 주장** | `file://${filePath}` 방식이 공백/특수문자에서 실패 |
| **검증 결과** | **부분 유효** |
| **실제 위험도** | 중간 |

**일반인 설명:**
> 파일 경로를 웹 주소로 바꿀 때 문제가 생길 수 있습니다. 예를 들어 `C:\내 문서\영상.mp4` 같이 한글이나 공백이 있는 경로가 제대로 변환되지 않을 수 있습니다.

**실제 상황:**
- Electron 환경에서는 대부분 정상 작동
- 하지만 특수한 경로(이모지, 특수문자 등)에서 문제 가능성 존재
- `pathToFileURL()` 사용이 더 안전한 방법

---

### 1.3 baeframe:// 프로토콜 미스매치 (중요!)

| 항목 | 내용 |
|------|------|
| **위치** | `web-viewer/open.html:201-204` vs `main/index.js:52-93` |
| **GPT 주장** | 웹뷰어에서 생성한 URL을 데스크톱 앱이 인식 못함 |
| **검증 결과** | **유효** |
| **실제 위험도** | 높음 |

**일반인 설명:**
> 웹 뷰어에서 "앱으로 열기" 버튼을 누르면 `baeframe://open?video=...` 형식의 링크가 생성됩니다. 하지만 데스크톱 앱은 이 형식을 이해하지 못합니다. 마치 영어로 말하는데 상대방은 한국어만 알아듣는 상황입니다.

**코드 증거:**
```javascript
// web-viewer/open.html - 이렇게 URL을 생성하지만
`baeframe://open?video=${videoUrl}&bframe=${bframeUrl}`

// main/index.js - 앱은 이렇게 처리함 (query string 미지원)
let filePath = url.replace(/^baeframe:\/\//, '');
// "open?video=..." 부분을 파일 경로로 해석하려고 시도 → 실패
```

---

### 1.4 앱 종료 시 강제 process.exit

| 항목 | 내용 |
|------|------|
| **위치** | `main/index.js:289-295` |
| **GPT 주장** | 남아있는 저장 작업이 잘릴 수 있음 |
| **검증 결과** | **부분 유효** |
| **실제 위험도** | 낮음 |

**일반인 설명:**
> 앱을 종료할 때 500ms(0.5초) 후에 강제로 종료합니다. 만약 그 사이에 파일 저장이 안 끝났다면 데이터가 손실될 수 있습니다. 마치 문서 저장 중에 컴퓨터 전원을 갑자기 끄는 것과 비슷합니다.

**실제 상황:**
- `before-quit` 이벤트에서 저장 확인 후 `quit` 이벤트 발생
- 500ms는 대부분의 경우 충분한 시간
- GPU hang 등 특수 상황 회피를 위한 안전장치로 보임

---

### 1.5 copyFile/deleteFile API 누락

| 항목 | 내용 |
|------|------|
| **위치** | `renderer/scripts/modules/review-data-manager.js:307, 358` |
| **GPT 주장** | preload에 해당 API가 없어서 fallback 동작 |
| **검증 결과** | **유효** |
| **실제 위험도** | 낮음 |

**일반인 설명:**
> 코드에서 파일 복사/삭제 기능을 호출하지만, 실제로 그 기능이 연결되어 있지 않습니다. 다행히 대체 방법(fallback)이 있어서 작동은 하지만, 개발자 콘솔에 경고가 계속 표시됩니다.

**코드 증거:**
```javascript
// review-data-manager.js에서 호출
await window.electronAPI.copyFile(...)  // 호출하지만

// preload.js에는 해당 API가 없음
// copyFile, deleteFile 함수 미정의
```

---

### 1.6 wheel 이벤트 passive 옵션 누락

| 항목 | 내용 |
|------|------|
| **위치** | `renderer/scripts/modules/timeline.js:133` |
| **GPT 주장** | preventDefault()가 무시될 수 있음 |
| **검증 결과** | **유효** |
| **실제 위험도** | 낮음 |

**일반인 설명:**
> 타임라인에서 마우스 휠을 사용할 때, 브라우저가 "이 스크롤을 막으면 안 돼!"라고 무시할 수 있습니다. 결과적으로 타임라인 줌 기능이 예상대로 작동하지 않을 수 있습니다.

---

### 1.7 video.play() Promise 미처리

| 항목 | 내용 |
|------|------|
| **위치** | `renderer/scripts/modules/video-player.js:306` |
| **GPT 주장** | play() 실패 시 처리가 없음 |
| **검증 결과** | **유효** |
| **실제 위험도** | 중간 |

**일반인 설명:**
> 영상 재생 버튼을 눌렀을 때, 만약 재생이 실패하면(예: 코덱 문제, 브라우저 정책) 사용자에게 아무런 안내가 없습니다. 재생 버튼을 눌러도 아무 반응이 없는 것처럼 보일 수 있습니다.

---

## 2. 성능 & 최적화

### 2.1 이벤트 리스너 정리 누락 (메모리 누수)

| 항목 | 내용 |
|------|------|
| **위치** | `drawing-canvas.js:601-604`, `timeline.js:2111-2118` |
| **GPT 주장** | destroy() 호출 시 리스너 제거 안 됨 |
| **검증 결과** | **유효** |
| **실제 위험도** | 중간 |

**일반인 설명:**
> 프로그램이 특정 기능을 "감시"하도록 설정해두었는데, 그 기능을 끌 때 감시도 같이 끄지 않습니다. 마치 집을 나갔는데 불을 끄지 않은 것처럼, 시간이 지나면 메모리가 낭비됩니다.

**코드 증거:**
```javascript
// drawing-canvas.js destroy()
destroy() {
  // 이벤트 리스너 제거는 canvas 요소 제거 시 자동으로 됨 ← 가정이지만 보장 안 됨
  log.info('DrawingCanvas 정리됨');
}

// timeline.js destroy()
destroy() {
  this.clearMarkers();
  // document.addEventListener로 추가한 리스너 제거 없음
  // ResizeObserver.disconnect() 없음
}
```

---

### 2.2 썸네일 전체 로드 시 메모리 스파이크

| 항목 | 내용 |
|------|------|
| **위치** | `main/ipc-handlers.js:493-531` |
| **GPT 주장** | 긴 영상에서 모든 썸네일을 한 번에 base64로 전송 |
| **검증 결과** | **유효** |
| **실제 위험도** | 중간~높음 (영상 길이에 따라) |

**일반인 설명:**
> 10분짜리 영상의 썸네일 수백 개를 한꺼번에 메모리에 올립니다. 마치 사진첩의 모든 사진을 한 번에 테이블 위에 펼치는 것과 같습니다. 영상이 길면 컴퓨터가 버거워할 수 있습니다.

---

### 2.3 어니언 스킨 임시 캔버스 매번 생성

| 항목 | 내용 |
|------|------|
| **위치** | `renderer/scripts/modules/drawing-manager.js:923-926` |
| **GPT 주장** | 매 프레임마다 새 캔버스 생성으로 GC 압박 |
| **검증 결과** | **유효** |
| **실제 위험도** | 중간 |

**일반인 설명:**
> 어니언 스킨(이전/다음 프레임 미리보기) 기능을 사용할 때마다 새 종이를 만들고 버립니다. 재활용하면 되는데 매번 새로 만들어서 쓰레기가 많이 생깁니다.

**코드 증거:**
```javascript
// _renderOnionFrame() 내부
const tempCanvas = document.createElement('canvas');  // 매번 새로 생성
tempCanvas.width = this.onionSkinCanvasElement.width;
tempCanvas.height = this.onionSkinCanvasElement.height;
```

---

### 2.4 이미지 로드 순차 await (병렬화 미적용)

| 항목 | 내용 |
|------|------|
| **위치** | `drawing-manager.js:624-644` |
| **GPT 주장** | 레이어가 많으면 렌더 지연 |
| **검증 결과** | **유효** |
| **실제 위험도** | 낮음~중간 |

**일반인 설명:**
> 레이어 10개가 있으면 1번 로드 → 2번 로드 → ... → 10번 로드 순서로 기다립니다. 동시에 로드하면 더 빠를 수 있는데 한 줄로 기다리고 있습니다.

---

### 2.5 캐시 용량 계산 시 UI 멈춤 가능성

| 항목 | 내용 |
|------|------|
| **위치** | `main/ipc-handlers.js:623-654` |
| **GPT 주장** | 캐시 디렉토리 전체를 재귀적으로 계산 |
| **검증 결과** | **부분 유효** |
| **실제 위험도** | 낮음 |

**일반인 설명:**
> 캐시 용량을 확인할 때 모든 파일을 하나씩 세어봅니다. 파일이 많으면 잠깐 앱이 멈춘 것처럼 보일 수 있습니다.

---

### 2.6 .bframe 파일 PNG base64 누적

| 항목 | 내용 |
|------|------|
| **위치** | `drawing-canvas.js:494-496` 등 |
| **GPT 주장** | 그리기 데이터가 계속 쌓이면 파일이 거대해짐 |
| **검증 결과** | **유효** |
| **실제 위험도** | 중간 |

**일반인 설명:**
> 그림을 그릴 때마다 이미지 데이터가 .bframe 파일에 쌓입니다. 많이 그리면 파일이 수십 MB가 될 수 있고, Google Drive 동기화가 느려집니다.

---

### 2.7 toDataURL 기반 썸네일 생성

| 항목 | 내용 |
|------|------|
| **위치** | `thumbnail-generator.js` |
| **GPT 주장** | CPU/메모리 비용이 큼 |
| **검증 결과** | **부분 유효** |
| **실제 위험도** | 낮음 |

**실제 상황:**
- quick/full 단계 분리 + abort 지원이 이미 구현됨 (GPT도 인정)
- toBlob() 방식이 더 효율적이지만 현재도 사용 가능한 수준

---

## 3. 코드 품질

### 3.1 validators.js 미사용 (중요!)

| 항목 | 내용 |
|------|------|
| **위치** | `shared/validators.js` 존재, `review-data-manager.js`에서 미호출 |
| **GPT 주장** | 데이터 로드 시 검증이 이루어지지 않음 |
| **검증 결과** | **유효** |
| **실제 위험도** | 중간 |

**일반인 설명:**
> 파일을 열 때 내용이 올바른지 확인하는 검사기가 이미 만들어져 있지만, 실제로 사용하지 않고 있습니다. 마치 보안 검색대가 있는데 그냥 지나가는 것과 같습니다.

**코드 증거:**
```javascript
// shared/validators.js에 validateReviewData() 함수 존재

// review-data-manager.js의 load() 함수에서
// validateReviewData()를 호출하지 않고 바로 데이터 사용
```

---

### 3.2 app.js 5352줄 - 거대한 단일 파일

| 항목 | 내용 |
|------|------|
| **위치** | `renderer/scripts/app.js` |
| **GPT 주장** | 유지보수 비용이 한계 |
| **검증 결과** | **유효** |
| **실제 위험도** | 낮음 (당장은) / 높음 (장기적) |

**일반인 설명:**
> 주 기능 파일이 5,352줄입니다. 일반 책으로 치면 약 150페이지 분량입니다. 한 파일에 모든 내용이 있어서 찾기도, 수정하기도 어렵습니다.

---

### 3.3 유틸 함수 중복

| 항목 | 내용 |
|------|------|
| **위치** | `renderer/scripts/app.js` vs `web-viewer/scripts/app.js` |
| **GPT 주장** | escapeHtml 등 함수가 중복 존재 |
| **검증 결과** | **유효** |
| **실제 위험도** | 낮음 |

**일반인 설명:**
> 같은 기능을 하는 코드가 두 군데에 따로 있습니다. 하나를 고치면 다른 쪽도 고쳐야 하는데 까먹기 쉽습니다.

---

### 3.4 하드코딩된 웹뷰어 URL

| 항목 | 내용 |
|------|------|
| **위치** | `main/ipc-handlers.js:349, 379` |
| **GPT 주장** | URL이 코드에 직접 박혀있음 |
| **검증 결과** | **유효** |
| **실제 위험도** | 낮음 |

**일반인 설명:**
> `https://baeframe.vercel.app/open.html`이 코드에 직접 적혀있습니다. 나중에 주소가 바뀌면 코드를 직접 수정해야 합니다.

---

### 3.5 미사용 IPC 핸들러 정리 필요

| 항목 | 내용 |
|------|------|
| **위치** | `main/ipc-handlers.js` |
| **GPT 주장** | 정의는 되어있지만 preload에 노출 안 됨 |
| **검증 결과** | **부분 유효** |
| **실제 위험도** | 매우 낮음 |

**실제 상황:**
- GPT가 언급한 `file:delete`, `file:read-text` 등은 현재 ipc-handlers.js에서 확인되지 않음
- 코드가 이미 정리되었거나 GPT가 오래된 버전을 참조한 것으로 보임

---

## 4. Electron 보안

### 4.1 sandbox: false 설정

| 항목 | 내용 |
|------|------|
| **위치** | `main/window.js:49` |
| **GPT 주장** | 가능하면 true 권장 |
| **검증 결과** | **부분 유효** |
| **실제 위험도** | 낮음 (내부 도구) |

**일반인 설명:**
> 웹 페이지가 컴퓨터의 민감한 부분에 접근하지 못하도록 "모래상자"(sandbox)에서 실행하는 게 안전합니다. 현재는 이 보호막이 꺼져있습니다.

**실제 상황:**
- 주석에 "electron-store 등 사용을 위해" 명시
- 내부 팀 도구이므로 외부 공격 위험 낮음
- 하지만 장기적으로 개선 권장

---

### 4.2 IPC 경로 검증 부재

| 항목 | 내용 |
|------|------|
| **위치** | `main/ipc-handlers.js` 전반 |
| **GPT 주장** | 파일 경로 검증 없이 사용 |
| **검증 결과** | **유효** |
| **실제 위험도** | 낮음 (내부 도구) |

**일반인 설명:**
> 파일 경로를 받아서 처리할 때, 그 경로가 안전한지 확인하지 않습니다. 예를 들어 `../../../중요파일` 같은 경로로 원치 않는 파일에 접근할 수 있습니다.

---

### 4.3 외부 네비게이션 차단 미설정

| 항목 | 내용 |
|------|------|
| **위치** | `main/window.js` |
| **GPT 주장** | setWindowOpenHandler/will-navigate 설정 권장 |
| **검증 결과** | **유효** |
| **실제 위험도** | 낮음 |

**일반인 설명:**
> 앱 안에서 외부 웹사이트로 이동하는 것을 막는 설정이 없습니다. 악성 링크를 클릭하면 앱 창 안에서 외부 사이트가 열릴 수 있습니다.

---

### 4.4 contextIsolation/nodeIntegration 설정

| 항목 | 내용 |
|------|------|
| **위치** | `main/window.js:47-48` |
| **GPT 주장** | 기본값 올바르게 설정됨 (잘된 점) |
| **검증 결과** | **확인됨 - 양호** |

**코드 증거:**
```javascript
webPreferences: {
  contextIsolation: true,   // 올바름
  nodeIntegration: false,   // 올바름
}
```

---

## 5. 아키텍처

### 5.1 싱글톤 패턴 남발

| 항목 | 내용 |
|------|------|
| **위치** | 여러 모듈 |
| **GPT 주장** | 테스트/다중 프로젝트 확장 시 문제 |
| **검증 결과** | **유효** |
| **실제 위험도** | 낮음 (단일 윈도우 앱) |

**일반인 설명:**
> 여러 모듈이 "전체 앱에서 하나만 존재"하도록 설계되어 있습니다. 지금은 괜찮지만, 나중에 여러 프로젝트를 동시에 열고 싶으면 큰 수정이 필요합니다.

---

### 5.2 이벤트 기반 통신 추적 어려움

| 항목 | 내용 |
|------|------|
| **위치** | EventTarget 기반 모듈들 |
| **GPT 주장** | 이벤트가 늘면 "스파게티"가 됨 |
| **검증 결과** | **부분 유효** |
| **실제 위험도** | 중간 |

**일반인 설명:**
> 모듈끼리 "이벤트"로 대화합니다. 이벤트가 많아지면 누가 누구에게 뭘 보내는지 파악하기 어려워집니다. 마치 단체 카톡방에서 대화가 엉키는 것과 비슷합니다.

---

### 5.3 shared 폴더 활용 부족

| 항목 | 내용 |
|------|------|
| **위치** | `shared/` 폴더 |
| **GPT 주장** | 공유 레이어로 더 활용 가능 |
| **검증 결과** | **유효** |
| **실제 위험도** | 낮음 |

**일반인 설명:**
> 데스크톱 앱과 웹 뷰어가 공유할 수 있는 코드 저장소가 있는데, 아직 충분히 활용하지 않고 있습니다.

---

## 우선순위별 수정 권장사항

### 즉시 수정 권장 (높은 우선순위)

| # | 항목 | 이유 |
|---|------|------|
| 1 | baeframe:// 프로토콜 미스매치 | "앱으로 열기" 기능이 작동 안 함 |
| 2 | validators.js 실제 사용 | 손상된 파일 로드 시 앱 오작동 가능 |
| 3 | video.play() 에러 처리 | 사용자에게 피드백 없이 재생 실패 |

### 개선 권장 (중간 우선순위)

| # | 항목 | 이유 |
|---|------|------|
| 4 | 이벤트 리스너 정리 | 장시간 사용 시 메모리 누수 |
| 5 | 썸네일 로드 최적화 | 긴 영상에서 성능 문제 |
| 6 | 어니언 스킨 캔버스 재사용 | 애니메이션 재생 성능 개선 |

### 장기 개선 사항 (낮은 우선순위)

| # | 항목 | 이유 |
|---|------|------|
| 7 | app.js 분리 | 유지보수성 향상 |
| 8 | IPC 경로 검증 추가 | 보안 강화 |
| 9 | sandbox: true 전환 검토 | 보안 강화 |

---

## GPT 리뷰 평가

| 평가 항목 | 점수 | 설명 |
|----------|------|------|
| 정확성 | 8/10 | 대부분 실제 코드와 일치, 일부 위치 오차 |
| 심각도 판단 | 7/10 | 일부 "심각"으로 표시된 항목이 실제로는 낮은 위험도 |
| 실용성 | 9/10 | 구체적인 수정 방향 제시 |
| 놓친 부분 | - | 최근 추가된 FFmpeg 관련 코드는 리뷰되지 않음 |

---

## 결론

GPT 코드 리뷰는 전반적으로 **정확하고 유용**합니다. 26개 항목 중 17개가 완전히 유효하고, 9개가 부분적으로 유효합니다. 완전히 틀린 항목은 없었습니다.

다만, 일부 항목의 "심각도"는 과장되어 있습니다. BAEFRAME은 내부 팀용 도구이므로 보안 관련 항목들의 실제 위험도는 낮습니다.

**가장 시급한 수정:** baeframe:// 프로토콜 파서 수정 (웹뷰어 ↔ 데스크톱 앱 연동 문제)
