# 재생목록 핫픽스 - 변환/데이터 소실/사전변환/썸네일 캐시 문제 해결

## 요약

| 항목 | 수정 파일 | 이유 | 우선순위 | 상태 |
|------|----------|------|---------|------|
| Phase 1: EBUSY 변환 실패 수정 | `main/ffmpeg-manager.js` | rename 시 파일 핸들 미해제로 EBUSY 오류 | 높음 | ⬜ 대기 |
| Phase 2: 재생목록 데이터 소실 수정 | `renderer/scripts/modules/playlist-manager.js`, `renderer/scripts/app.js` | 미저장 재생목록 데이터 소실 | 높음 | ⬜ 대기 |
| Phase 3: 썸네일 캐시 미저장 수정 | `renderer/scripts/modules/thumbnail-generator.js` | Phase 2 abort 시 캐시 저장 누락 | 높음 | ⬜ 대기 |
| Phase 4: 재생목록 사전 변환 구현 | `main/ffmpeg-manager.js`, `main/ipc-handlers.js`, `preload/preload.js`, `renderer/scripts/app.js` | 다음 영상 사전 변환으로 UX 개선 | 중간 | ⬜ 대기 |

## 배경 및 목적

재생목록 기능에서 네 가지 문제가 발견됨:
1. **변환이 필요한 파일이 재생 시점에야 변환** → 사용자 대기 시간 발생
2. **변환 후 파일 rename에서 EBUSY 오류** → 변환 실패
3. **미공유 재생목록(파일 미생성 상태)에서 껐다 켜면 데이터 소실**
4. **썸네일이 매번 재생성됨** → 이미 열었던 영상도 "빠른 썸네일 생성 중..." 오버레이 반복 표시

---

## 문제 1: EBUSY 변환 실패

### 증상
```
코덱 변환 실패: EBUSY: resource busy or locked, rename
'C:\Users\user\AppData\Roaming\baeframe\transcoded\47c4742f20071704\converting.mp4'
-> 'C:\Users\user\AppData\Roaming\baeframe\transcoded\47c4742f20071704\converted.mp4'
```

### 원인 분석

**파일**: `main/ffmpeg-manager.js:675`

```javascript
// 문제 코드
if (code === 0) {
  try {
    fs.renameSync(tempPath, outputPath);  // ← 여기서 EBUSY 발생
    // ...
  } catch (e) {
    log.error('트랜스코딩 후처리 실패', { error: e.message });
    reject(e);  // ← 재시도 없이 바로 실패
  }
}
```

**근본 원인**:
1. FFmpeg 프로세스의 `close` 이벤트가 발생해도, **Windows에서 파일 핸들이 즉시 해제되지 않을 수 있음**
2. `fs.renameSync()`는 동기적으로 즉시 실행되어, 파일이 아직 잠겨있을 때 EBUSY 오류 발생
3. **재시도 로직이 전혀 없음** - 한 번 실패하면 바로 reject 처리
4. Windows의 바이러스 백신이나 검색 인덱서가 새로 생성된 파일을 스캔하면서 핸들을 잡고 있을 수도 있음

### 해결 방안

`fs.renameSync`를 **비동기 retry 로직이 있는 rename 함수**로 교체:

```javascript
// main/ffmpeg-manager.js - 변환 완료 후 rename 부분 (line 672-697)

// 해결: 비동기 retry rename 함수 추가
async _retryRename(src, dest, maxRetries = 5, delay = 200) {
  for (let attempt = 0; attempt < maxRetries; attempt++) {
    try {
      await fs.promises.rename(src, dest);
      return; // 성공
    } catch (err) {
      if (err.code === 'EBUSY' && attempt < maxRetries - 1) {
        log.warn(`rename 재시도 (${attempt + 1}/${maxRetries})`, {
          src, dest, error: err.code
        });
        await new Promise(r => setTimeout(r, delay * (attempt + 1)));
      } else {
        throw err; // EBUSY가 아니거나 최대 재시도 초과
      }
    }
  }
}
```

**수정할 코드** (`main/ffmpeg-manager.js:672-697`):

```javascript
// 기존 (line 672-697)
if (code === 0) {
  try {
    fs.renameSync(tempPath, outputPath);  // 동기, 재시도 없음
    // ...
  }
}

// 수정 후
if (code === 0) {
  // close 이벤트 후 파일 핸들 해제 대기 (Windows)
  const postProcess = async () => {
    try {
      await this._retryRename(tempPath, outputPath, 5, 200);

      // ===== 아래 후처리 코드는 기존 코드와 동일하게 유지 (line 677-693) =====
      const meta = {
        originalPath: filePath,
        originalSize: stats.size,
        originalMtime: stats.mtimeMs,
        originalCodec: codecInfo.codecName,
        convertedAt: new Date().toISOString(),
        settings: { encoder: encoder.name, args: encoder.args }
      };
      fs.writeFileSync(metaPath, JSON.stringify(meta, null, 2));

      log.info('트랜스코딩 완료', { filePath, outputPath });

      // 캐시 정리 (비동기)
      this._cleanupCacheIfNeeded().catch(() => {});

      if (onProgress) onProgress(100);
      resolve({ success: true, outputPath, fromCache: false });  // ← 반드시 resolve 호출!
    } catch (e) {
      log.error('트랜스코딩 후처리 실패', { error: e.message });
      reject(e);
    }
  };
  postProcess();  // await 없이 호출 (close 이벤트 핸들러는 동기이므로, Promise 클로저로 resolve/reject 전달)
}
```

**핵심 변경점**:
- `fs.renameSync` → `fs.promises.rename` + retry
- 최대 5회 재시도, 200ms → 400ms → 600ms → 800ms → 1000ms 지연
- EBUSY 오류에만 재시도, 다른 오류는 즉시 실패

---

## 문제 2: 재생목록 데이터 소실

### 증상
재생목록을 공유하지 않은 상태(`.bplaylist` 파일 미생성)에서 재생목록을 껐다가 키면 내역이 사라짐.

### 원인 분석 (복합적 - 4가지 원인)

#### 원인 2-1: `close()` 메서드의 조건부 저장 버그

**파일**: `renderer/scripts/modules/playlist-manager.js:240-253`

```javascript
async close() {
  if (this.isModified && this.playlistPath) {  // ← playlistPath가 null이면 저장 안 함!
    await this.save();
  }

  this.currentPlaylist = null;   // ← 데이터 소실
  this.playlistPath = null;
  this.currentIndex = -1;
  this.isModified = false;

  this.onPlaylistClosed?.();
}
```

**문제**: 새 재생목록은 `playlistPath = null` 상태. `close()` 호출 시 `this.isModified && this.playlistPath` 조건이 **false**가 되어 저장을 건너뛰고, `this.currentPlaylist = null`로 데이터가 즉시 소실됨.

#### 원인 2-2: 닫기 버튼이 `close()` 호출

**파일**: `renderer/scripts/app.js:6247-6250`

```javascript
// 닫기 버튼
elements.btnPlaylistClose?.addEventListener('click', async () => {
  await playlistManager.close();   // ← 미저장 데이터 소실 트리거
  hidePlaylistSidebar();
});
```

사용자가 재생목록 사이드바의 닫기(X) 버튼을 클릭하면 `close()`가 호출됨.
이때 `playlistPath`가 null이면 원인 2-1에 의해 데이터 소실.

> **참고**: 헤더의 재생목록 토글 버튼(`btnPlaylist`)은 `hidePlaylistSidebar()`만 호출하여 DOM만 숨기므로 데이터는 유지됨. 사용자가 어떤 버튼을 눌렀느냐에 따라 데이터 소실 여부가 달라져서 "간헐적"으로 보임.

#### 원인 2-3: 자동 저장도 같은 조건 사용

**파일**: `renderer/scripts/app.js:6188-6197`

```javascript
playlistManager._autoSaveTimeout = setTimeout(async () => {
  if (playlistManager.isModified && playlistManager.playlistPath) {  // ← 역시 playlistPath 필요
    try {
      await playlistManager.save();
    } catch (err) {
      log.warn('재생목록 자동 저장 실패', err);
    }
  }
}, 2000);
```

자동 저장도 `playlistPath`가 null이면 동작하지 않아, 새 재생목록은 **절대 자동 저장되지 않음**.

#### 원인 2-4: `state.currentFile.videoPath` 참조 오류

**파일**: `renderer/scripts/app.js:6235-6238`

```javascript
if (!playlistManager.isActive()) {
  playlistManager.createNew();
  if (state.currentFile) {
    playlistManager.addItems([state.currentFile.videoPath]).then(updatePlaylistUI);
    //                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ← undefined!
  }
}
```

`state.currentFile`은 `loadVideo()` (line 3053)에서 **문자열**(filePath)로 설정됨:
```javascript
state.currentFile = filePath;  // string, 예: "G:\\Videos\\test.mp4"
```

그러나 `state.currentFile.videoPath`는 문자열에 없는 속성이므로 **undefined**.
→ `addItems([undefined])` → `isVideoFile(undefined)` → false → 아이템 추가 안 됨

결과적으로 데이터 소실 후 재생목록을 다시 열었을 때, 현재 재생 중인 영상도 추가되지 않아 **빈 재생목록**이 표시됨.

### 해결 방안

#### 수정 2-1: `close()`에서 미저장 재생목록도 저장

**파일**: `renderer/scripts/modules/playlist-manager.js`

```javascript
// 기존
async close() {
  if (this.isModified && this.playlistPath) {
    await this.save();
  }
  // ...
}

// 수정 후
async close() {
  // 수정되었고 저장 경로가 있으면 파일로 저장
  if (this.isModified && this.playlistPath) {
    await this.save();
  }
  // 아이템이 있지만 파일로 저장되지 않은 경우 → localStorage 임시 저장
  else if (this.currentPlaylist && this.currentPlaylist.items.length > 0 && !this.playlistPath) {
    this._saveToLocalStorage();
  }

  this.currentPlaylist = null;
  this.playlistPath = null;
  this.currentIndex = -1;
  this.isModified = false;

  this.onPlaylistClosed?.();
}
```

**localStorage 저장/복원 메서드 추가**:

```javascript
_saveToLocalStorage() {
  try {
    const data = JSON.stringify({
      playlist: this.currentPlaylist,
      currentIndex: this.currentIndex,
      savedAt: new Date().toISOString()
    });
    localStorage.setItem('baeframe_temp_playlist', data);
    log.info('재생목록 임시 저장 (localStorage)');
  } catch (err) {
    log.warn('localStorage 저장 실패', { error: err.message });
  }
}

_restoreFromLocalStorage() {
  try {
    const raw = localStorage.getItem('baeframe_temp_playlist');
    if (!raw) return null;

    const data = JSON.parse(raw);
    // 주의: validatePlaylistData는 모듈 레벨 함수 (line 98-106), this 없이 직접 호출
    if (!data.playlist || !validatePlaylistData(data.playlist)) return null;

    // 24시간 이상 된 데이터는 무시
    const savedAt = new Date(data.savedAt);
    if (Date.now() - savedAt.getTime() > 24 * 60 * 60 * 1000) {
      localStorage.removeItem('baeframe_temp_playlist');
      return null;
    }

    return data;
  } catch (err) {
    log.warn('localStorage 복원 실패', { error: err.message });
    return null;
  }
}

_clearLocalStorage() {
  localStorage.removeItem('baeframe_temp_playlist');
}
```

#### 수정 2-2: 재생목록 재열기 시 localStorage에서 복원

**파일**: `renderer/scripts/app.js` (btnPlaylist 클릭 핸들러)

```javascript
// 기존
elements.btnPlaylist?.addEventListener('click', () => {
  if (elements.playlistSidebar.classList.contains('hidden')) {
    showPlaylistSidebar();
    if (!playlistManager.isActive()) {
      playlistManager.createNew();
      if (state.currentFile) {
        playlistManager.addItems([state.currentFile.videoPath]).then(updatePlaylistUI);
      }
    }
  } else {
    hidePlaylistSidebar();
  }
});

// 수정 후
elements.btnPlaylist?.addEventListener('click', () => {
  if (elements.playlistSidebar.classList.contains('hidden')) {
    showPlaylistSidebar();
    if (!playlistManager.isActive()) {
      // localStorage에서 임시 저장된 재생목록 복원 시도
      const tempData = playlistManager._restoreFromLocalStorage();
      if (tempData) {
        playlistManager.currentPlaylist = tempData.playlist;
        playlistManager.currentIndex = tempData.currentIndex;
        playlistManager.isModified = true;
        playlistManager._clearLocalStorage();
        playlistManager.onPlaylistLoaded?.(playlistManager.currentPlaylist);
        log.info('임시 저장된 재생목록 복원');
      } else {
        playlistManager.createNew();
        // 현재 영상이 있으면 추가 (버그 수정: state.currentFile은 문자열)
        if (state.currentFile) {
          playlistManager.addItems([state.currentFile]).then(updatePlaylistUI);
          //                        ^^^^^^^^^^^^^^^^^ 수정: .videoPath 제거
        }
      }
    }
  } else {
    hidePlaylistSidebar();
  }
});
```

#### 수정 2-3: 자동 저장에서 미저장 재생목록도 처리

**파일**: `renderer/scripts/app.js` (onPlaylistModified)

```javascript
// 기존
if (playlistManager.isModified && playlistManager.playlistPath) {
  await playlistManager.save();
}

// 수정 후: playlistPath가 없어도 아이템이 있으면 자동으로 경로 생성하여 저장
if (playlistManager.isModified) {
  if (playlistManager.playlistPath) {
    await playlistManager.save();
  } else if (playlistManager.getItemCount() > 0) {
    // 경로 없는 경우: save()가 첫 아이템 기준으로 경로를 자동 생성함
    try {
      await playlistManager.save();
      log.info('재생목록 최초 자동 저장 완료');
    } catch (err) {
      // 저장 경로 생성 실패 시 localStorage로 대체
      playlistManager._saveToLocalStorage();
    }
  }
}
```

#### 수정 2-4: `state.currentFile.videoPath` → `state.currentFile`

**파일**: `renderer/scripts/app.js:6238`

```javascript
// 기존
playlistManager.addItems([state.currentFile.videoPath])

// 수정 후
playlistManager.addItems([state.currentFile])
```

---

## 문제 3: 썸네일 캐시가 저장되지 않아 매번 재생성

### 증상
이미 열었던 영상을 다시 열어도 매번 화면이 어두워지며 "빠른 썸네일 생성 중... (N/M)" 오버레이가 표시됨. 한번 생성한 썸네일이 캐시되지 않는 것처럼 동작.

### 원인 분석

**파일**: `renderer/scripts/modules/thumbnail-generator.js:139-168`

썸네일 생성은 2단계로 동작:
- **Phase 1** (빠른 스캔): 5초 간격으로 전체 커버 → 완료 시 오버레이 해제, 사용자 작업 가능
- **Phase 2** (세부 채움): 1초 간격으로 사이사이 채우기 → 백그라운드에서 진행

**핵심 버그**: `_saveToCache()`가 **Phase 2 완료 후에만** 호출됨 (line 168):

```javascript
// Phase 1 완료 (line 141-149)
await this._generatePhase1(signal);
if (signal.aborted) return;
this.isQuickReady = true;
this._emit('quickReady');  // → 오버레이 해제 → 사용자 작업 시작

// Phase 2 시작 (line 157-158) - 백그라운드
await this._generatePhase2(signal);

if (signal.aborted) return;  // ← 다른 파일 열면 abort → 여기서 즉시 return!

// ===== 캐시 저장 =====
await this._saveToCache();    // ← 이 코드에 절대 도달하지 못함!
```

**재현 시나리오**:

```
1. 파일 A 열기
2. Phase 1 완료 → 오버레이 사라짐 (사용자 작업 가능)
3. Phase 2 백그라운드 진행 중... (5분 영상 = 240개 세부 썸네일, 수십 초 소요)
4. 사용자가 파일 B 열기 (또는 재생목록에서 다음 파일로 이동)
   → generateThumbnails() 재호출 → thumbnailGenerator.clear()
   → abortController.abort() → Phase 2 중단
5. Phase 2의 signal.aborted 체크 → return → _saveToCache() 미실행!
6. 파일 A의 썸네일이 디스크에 저장되지 않음

7. 나중에 파일 A 다시 열기
   → thumbnailCheckValid() → 캐시 없음 (저장된 적 없으므로)
   → Phase 1 재실행 → "빠른 썸네일 생성 중..." 다시 표시!
```

Phase 2 소요 시간 (예상):
- 5분 영상: ~240개 × ~200ms/프레임 = **~48초**
- 10분 영상: ~480개 = **~96초**
- 30분 영상: ~1440개 = **~288초 (약 5분)**

사용자가 Phase 2 완료 전에 다른 파일로 이동하는 것은 극히 정상적인 사용 패턴이므로, **사실상 캐시가 거의 저장되지 않는 상황**.

### 해결 방안

**Phase 1 완료 직후에도 캐시를 저장**하여, Phase 2가 abort 되어도 최소한 Phase 1 썸네일은 캐시에 남도록 함.

**파일**: `renderer/scripts/modules/thumbnail-generator.js`

```javascript
// 기존 (line 139-168)
await this._generatePhase1(signal);
if (signal.aborted) return;

this.isQuickReady = true;
this._emit('quickReady', { count: this.thumbnailMap.size });

await this._delay(100);
if (signal.aborted) return;

await this._generatePhase2(signal);
if (signal.aborted) return;    // ← abort 시 캐시 저장 안 됨

await this._saveToCache();     // ← Phase 2 완료 후에만 저장

// 수정 후
await this._generatePhase1(signal);
if (signal.aborted) return;

this.isQuickReady = true;
this._emit('quickReady', { count: this.thumbnailMap.size });

// ===== Phase 1 캐시 저장 (핵심 수정) =====
await this._saveToCache();  // Phase 1만이라도 캐시에 저장
log.info('Phase 1 캐시 저장 완료', { count: this.thumbnailMap.size });

await this._delay(100);
if (signal.aborted) return;  // abort 되어도 Phase 1 캐시는 이미 저장됨!

await this._generatePhase2(signal);
// ⚠️ Phase 2 abort 시 _saveToCache() 호출 금지!
// clear()가 이미 호출되어 thumbnailMap이 비어있고 currentVideoHash가 null이므로
// _saveToCache()가 빈 데이터를 저장하거나 아예 bail out 됨.
// Phase 1 캐시만으로 충분. (자세한 설명은 아래 "구현 시 주의사항" 참조)
if (signal.aborted) return;

// Phase 2 완료 시 최종 캐시 저장 (Phase 1 + Phase 2 모든 썸네일)
await this._saveToCache();
```

**핵심 변경점**:
- Phase 1 완료 직후 `_saveToCache()` 호출 추가 (line 148 이후)
- Phase 2 abort 시에는 캐시 저장 **안 함** (clear()에 의해 이미 데이터가 초기화되었으므로)
- Phase 1 캐시만으로도 다음 로드 시 오버레이 없이 즉시 표시
- Phase 2가 정상 완료되면 전체 캐시(1초 간격)로 덮어쓰기

**부분 캐시 로드 시 Phase 2 보완**: 캐시에서 로드 시 `isFullReady = true`가 설정되어 Phase 2가 실행되지 않는 문제 대응

현재 캐시 로드 코드 (thumbnail-generator.js:113-114):
```javascript
this.isQuickReady = true;
this.isFullReady = true;  // ← Phase 1만 캐시된 경우에도 true!
```

Phase 1 캐시(5초 간격)만 저장된 상태에서 로드하면 `isFullReady = true`가 되어 Phase 2(1초 간격)가 영원히 실행되지 않음. **이것은 의도된 트레이드오프**: 5초 간격 썸네일로도 충분히 사용 가능하며, 매번 Phase 2를 재실행하면 캐시의 의미가 반감됨. Phase 2가 정상 완료된 경우 전체 캐시로 덮어쓰기되므로 점진적으로 개선됨.

**추가 개선**: 캐시에서 로드 시 오버레이 텍스트 변경

**파일**: `renderer/scripts/app.js` (generateThumbnails 함수)

```javascript
// 기존 (line 3175-3176)
loadingOverlay?.classList.add('active');
loadingText.textContent = '썸네일 생성 중...';

// 수정 후: quickReady 이벤트에서 fromCache 여부를 확인
const onQuickReady = (e) => {
  // 캐시에서 로드된 경우 오버레이를 즉시 숨김 (토스트 없음)
  if (e.detail.fromCache) {
    loadingOverlay?.classList.remove('active');
    log.info('캐시에서 썸네일 로드 완료');
    return;
  }
  // 새로 생성된 경우
  loadingOverlay?.classList.remove('active');
  showToast('미리보기 준비 완료! (세부 생성 중...)', 'success');
};
```

---

## 문제 4: 재생목록 사전 변환 미작동

### 증상
재생목록에서 변환이 필요한 파일이 있을 때, 다음 영상으로 이동해야 그제야 변환이 시작됨. 사용자가 매번 변환 완료를 기다려야 함.

### 원인 분석

**현재 흐름**:
```
아이템 클릭/다음 버튼 → selectItem() → onItemSelected 콜백
  → loadVideoFromPlaylist(item)
    → loadVideo(item.videoPath)
      → ffmpegProbeCodec() → 미지원 코덱 감지
        → ffmpegCheckCache() → 캐시 없음
          → showTranscodeOverlay() → [사용자 대기] → 변환 완료 → 영상 재생
```

**문제점**:
1. 변환이 **재생 시점에만** 수행됨 (on-demand)
2. 다음 영상을 **미리 변환하는 로직 없음**
3. `videoPlayer.ended` 이벤트 (app.js:504-508)에 **자동 재생 다음 아이템 로직도 없음**

### 해결 방안

#### 설계: 백그라운드 사전 변환 시스템

```
[재생목록 아이템 추가] ──→ 코덱 확인 ──→ 변환 필요? ──→ 큐에 추가
[현재 영상 재생 중]   ──→ 다음 아이템 코덱 확인 ──→ 변환 필요? ──→ 백그라운드 변환 시작
[영상 재생 완료]      ──→ 자동재생 설정 확인 ──→ 다음 아이템 로드 (이미 변환 완료)
```

#### 수정 4-1: 사전 변환 큐 시스템 (Main Process)

**파일**: `main/ffmpeg-manager.js`

새 메서드 추가:

```javascript
/**
 * 사전 변환 시작 (백그라운드, 낮은 우선순위)
 * 이미 변환 중이면 큐에 추가만 함
 */
async preTranscode(filePath, onProgress = null) {
  // 참고: transcode()의 시그니처는 transcode(filePath, onProgress = null, _options = {})
  //       onProgress 콜백을 전달해야 IPC 핸들러에서 진행률 이벤트를 보낼 수 있음

  // 캐시 확인 - 이미 변환되어 있으면 스킵
  const cacheCheck = await this.checkCache(filePath);
  if (cacheCheck.valid) {
    return { success: true, outputPath: cacheCheck.convertedPath, fromCache: true };
  }

  // 코덱 확인 - 변환 불필요하면 스킵
  const codecInfo = await this.probeCodec(filePath);
  if (codecInfo.isSupported) {
    return { success: true, noConversionNeeded: true };
  }

  // 이미 해당 파일이 변환 중인지 확인
  for (const [, task] of this.activeProcesses) {
    if (task.filePath === filePath) {
      return { success: false, reason: 'already-in-progress' };
    }
  }

  // 변환 실행 (onProgress 콜백 전달)
  return this.transcode(filePath, onProgress);
}
```

#### 수정 4-2: IPC 핸들러 추가

**파일**: `main/ipc-handlers.js`

```javascript
// 백그라운드 사전 변환 (진행률은 별도 이벤트로 전송)
ipcMain.handle('ffmpeg:pre-transcode', async (event, filePath) => {
  const mainWindow = getMainWindow();

  await ffmpegManager.initialize();
  if (!ffmpegManager.isAvailable()) {
    return { success: false, error: 'FFmpeg 미설치' };
  }

  try {
    const result = await ffmpegManager.preTranscode(filePath, (progress) => {
      if (mainWindow && !mainWindow.isDestroyed()) {
        mainWindow.webContents.send('ffmpeg:pre-transcode-progress', { filePath, progress });
      }
    });
    return { success: true, ...result };
  } catch (error) {
    return { success: false, error: error.message };
  }
});
```

#### 수정 4-3: Preload API 추가

**파일**: `preload/preload.js`

```javascript
ffmpegPreTranscode: (filePath) => ipcRenderer.invoke('ffmpeg:pre-transcode', filePath),
onPreTranscodeProgress: (callback) => {
  ipcRenderer.on('ffmpeg:pre-transcode-progress', (event, data) => callback(data));
},
```

#### 수정 4-4: 렌더러에서 사전 변환 트리거

**파일**: `renderer/scripts/app.js`

**아이템 추가 시 코덱 확인 및 사전 변환 시작**:

```javascript
// initPlaylistFeature() 내 기존 콜백 교체 (app.js:6178의 기존 할당을 대체)

// 재생목록 로드/수정 시 사전 변환 트리거
playlistManager.onPlaylistLoaded = async (playlist) => {
  log.info('재생목록 로드됨', { name: playlist.name });
  updatePlaylistUI();

  // 모든 아이템의 코덱을 확인하고 필요한 것들을 사전 변환
  preTranscodePlaylistItems();
};
```

**사전 변환 함수**:

```javascript
async function preTranscodePlaylistItems() {
  const playlistManager = getPlaylistManager();
  if (!playlistManager.isActive()) return;

  const ffmpegAvailable = await window.electronAPI.ffmpegIsAvailable();
  if (!ffmpegAvailable) return;

  const items = playlistManager.getItems();
  const currentIndex = playlistManager.currentIndex;

  // 현재 아이템 다음부터 순서대로 확인 (우선순위: 바로 다음 아이템)
  for (let offset = 1; offset < items.length; offset++) {
    const targetIndex = (currentIndex + offset) % items.length;
    const item = items[targetIndex];

    try {
      // 코덱 확인
      const codecInfo = await window.electronAPI.ffmpegProbeCodec(item.videoPath);
      if (!codecInfo.success || codecInfo.isSupported) continue;

      // 캐시 확인
      const cacheResult = await window.electronAPI.ffmpegCheckCache(item.videoPath);
      if (cacheResult.valid) continue;

      // 변환 필요 - 백그라운드 시작
      log.info('사전 변환 시작', { fileName: item.fileName, index: targetIndex });
      window.electronAPI.ffmpegPreTranscode(item.videoPath)
        .then(result => {
          if (result.success) {
            log.info('사전 변환 완료', { fileName: item.fileName });
          }
        })
        .catch(err => {
          log.warn('사전 변환 실패', { fileName: item.fileName, error: err.message });
        });

      // 한 번에 하나만 사전 변환 (시스템 부하 방지)
      break;
    } catch (err) {
      log.warn('사전 변환 코덱 확인 실패', { fileName: item.fileName, error: err.message });
    }
  }
}
```

**아이템 선택 후 다음 아이템 사전 변환**:

```javascript
// 기존 onItemSelected 콜백 교체 (app.js:6199의 기존 할당을 대체)
playlistManager.onItemSelected = async (item, index) => {
  log.info('재생목록 아이템 선택', { index, fileName: item.fileName });
  await loadVideoFromPlaylist(item);
  updatePlaylistCurrentItem();
  updatePlaylistPosition();

  // 다음 아이템 사전 변환 트리거
  preTranscodePlaylistItems();
};
```

#### 수정 4-5: 영상 종료 시 자동 재생 다음 아이템

**파일**: `renderer/scripts/app.js:504-508`

```javascript
// 기존
videoPlayer.addEventListener('ended', () => {
  elements.btnPlay.innerHTML = playIconSVG;
  drawingManager.setPlaying(false);
  timeline.setPlayingState(false);
});

// 수정 후
videoPlayer.addEventListener('ended', () => {
  elements.btnPlay.innerHTML = playIconSVG;
  drawingManager.setPlaying(false);
  timeline.setPlayingState(false);

  // 재생목록 자동 재생
  const playlistManager = getPlaylistManager();
  if (playlistManager.isActive() && playlistManager.getAutoPlay() && playlistManager.hasNext()) {
    log.info('자동 재생: 다음 아이템으로 이동');
    playlistManager.next();
  }
});
```

---

## 수정 파일 목록

| 파일 | 수정 내용 | Phase |
|------|----------|-------|
| `main/ffmpeg-manager.js` | `_retryRename()` 추가, `renameSync` → retry rename 교체, `preTranscode()` 추가 | 1, 4 |
| `main/ipc-handlers.js` | `ffmpeg:pre-transcode` IPC 핸들러 추가 | 4 |
| `preload/preload.js` | `ffmpegPreTranscode`, `onPreTranscodeProgress` API 추가 | 4 |
| `renderer/scripts/modules/playlist-manager.js` | `close()` 수정, `_saveToLocalStorage()` / `_restoreFromLocalStorage()` / `_clearLocalStorage()` 추가 | 2 |
| `renderer/scripts/modules/thumbnail-generator.js` | Phase 1 완료 직후 `_saveToCache()` 추가 (Phase 2 abort 시 저장 불가 → Phase 1 저장으로 해결) | 3 |
| `renderer/scripts/app.js` | 닫기 버튼 로직 수정, `state.currentFile.videoPath` → `state.currentFile` 수정, 자동 저장 조건 수정, `preTranscodePlaylistItems()` 추가, `ended` 이벤트에 자동 재생 추가, 재생목록 복원 로직 추가, 캐시 로드 시 오버레이 텍스트 분기 | 2, 3, 4 |

## 리스크 및 우려 사항

| 리스크 | 심각도 | 완화 방안 |
|--------|--------|----------|
| 사전 변환이 현재 재생에 영향 (CPU/IO 경쟁) | 중간 | 한 번에 하나만 변환, 현재 재생 파일 변환 우선 |
| localStorage 용량 제한 (5MB) | 낮음 | 재생목록 데이터는 매우 작음 (수 KB), 썸네일 Data URL이 큰 경우 대비 |
| retry rename이 계속 실패하는 경우 | 낮음 | 최대 5회 재시도, 총 3초 대기 후 실패 → 사용자에게 명확한 에러 메시지 |
| 자동 재생이 의도치 않게 작동 | 낮음 | autoPlay 설정이 명시적으로 켜져 있을 때만 작동 (기본값 false) |
| Phase 1 캐시 저장 후 Phase 2 저장 시 IPC 오버헤드 | 낮음 | 캐시 저장은 비동기이며, Phase 1 썸네일 수가 적어 (5초 간격) 저장 시간 짧음 |

## 테스트 방법

### Phase 1 테스트 (EBUSY)
1. 변환 필요한 영상(MPEG-4, PNG MOV 등) 준비
2. 해당 영상을 로드하여 변환 실행
3. 변환 완료 후 EBUSY 오류 없이 정상 완료 확인
4. 로그에서 retry 발생 여부 확인

### Phase 2 테스트 (데이터 소실)
1. 재생목록 생성 후 아이템 추가 (파일 공유/저장 하지 않음)
2. 재생목록 사이드바의 닫기(X) 버튼 클릭
3. 재생목록 다시 열기 → 이전 데이터가 복원되는지 확인
4. 헤더의 재생목록 토글 버튼으로도 동일 테스트
5. `state.currentFile` 수정 후 현재 영상이 자동 추가되는지 확인

### Phase 3 테스트 (썸네일 캐시)
1. 영상 파일 열기 → "빠른 썸네일 생성 중..." 오버레이 표시 확인
2. Phase 1 완료 후 오버레이 사라짐 확인
3. Phase 2 완료 **전에** 다른 파일 열기 (abort 유발)
4. 첫 번째 파일 다시 열기 → 캐시에서 로드되어 오버레이 **미표시** (또는 순간적으로만 표시) 확인
5. 로그에서 "캐시에서 썸네일 로드 완료" 메시지 확인

### Phase 4 테스트 (사전 변환)
1. 변환 필요한 영상 여러 개를 재생목록에 추가
2. 첫 번째 영상 재생 중 다음 영상이 백그라운드에서 변환되는지 확인
3. 다음 영상으로 이동 시 즉시 재생되는지 확인
4. 자동 재생 설정 후 영상 종료 시 자동으로 다음 아이템 이동 확인

---

## 구현 시 주의사항 (필독)

새로운 세션에서 구현할 때 반드시 확인해야 할 사항들:

### Phase 1 (EBUSY)
1. **`postProcess()`는 await 없이 호출**: FFmpeg의 `close` 이벤트 핸들러는 동기 컨텍스트이므로, `postProcess()`를 `await` 없이 호출함. `resolve()`/`reject()`는 외부 Promise의 클로저에 의해 캡처되어 있으므로 비동기 함수 내부에서 정상 동작.
2. **후처리 코드 전체를 포함해야 함**: `_retryRename()` 후에 반드시 meta 작성, `_cleanupCacheIfNeeded()`, `onProgress(100)`, **`resolve()`** 호출이 있어야 함. `resolve()`를 빠뜨리면 Promise가 영원히 resolve 되지 않아 변환 UI가 멈춤.
3. **`_retryRename` 메서드 위치**: FFmpegManager 클래스의 인스턴스 메서드로 추가. `transcode()` 메서드 근처에 배치 권장.

### Phase 2 (데이터 소실)
1. **`validatePlaylistData`는 클래스 메서드가 아닌 모듈 레벨 함수** (playlist-manager.js:98-106). `_restoreFromLocalStorage()` 내에서 `this.validatePlaylistData()`가 아니라 `validatePlaylistData()`로 직접 호출해야 함.
2. **`save()` 메서드는 `playlistPath`가 null일 때 첫 아이템 폴더 기준으로 경로를 자동 생성** (playlist-manager.js:220-222). 따라서 수정 2-3에서 `playlistManager.save()`를 호출하면 `.bplaylist` 파일이 자동 생성됨.
3. **`currentPlaylist`, `currentIndex`, `isModified`는 퍼블릭 속성**: 수정 2-2에서 직접 할당(`playlistManager.currentPlaylist = ...`)이 가능함.

### Phase 3 (썸네일 캐시) ⚠️ 가장 주의 필요
1. **Phase 2 abort 시 `_saveToCache()` 호출 금지**:
   - `clear()` (thumbnail-generator.js:490-502)는 `abort()` 호출과 **동시에** `thumbnailMap.clear()`, `currentVideoHash = null`을 실행
   - Phase 2가 abort를 감지한 시점에 인스턴스 상태는 이미 초기화됨
   - `_saveToCache()`는 line 192에서 `if (!this.currentVideoHash || !this.videoSrc)` 조건에 걸려 bail out
   - 따라서 Phase 2 abort 시의 `_saveToCache()`는 **아무것도 저장하지 않거나 빈 데이터를 저장**
   - **Phase 1 직후 저장만이 유일하게 안전한 저장 시점**

2. **부분 캐시 = `isFullReady: true`**: Phase 1(5초 간격)만 캐시된 상태에서 로드 시 `isFullReady = true`가 설정되어 Phase 2(1초 간격)는 실행되지 않음. 이는 **의도된 트레이드오프** - 5초 간격 썸네일로 충분히 동작하며, Phase 2가 정상 완료되면 전체 캐시로 덮어쓰기됨.

3. **`generate()` 호출 순서** (app.js:3200-3255): `clear()` → 리스너 등록 → `generate(videoSrc)` (await 없음). `clear()`가 먼저 호출되므로 이전 세대의 abort 처리가 선행됨.

### Phase 4 (사전 변환)
1. **`preTranscode(filePath, onProgress)`**: onProgress 파라미터를 받아서 `this.transcode(filePath, onProgress)`로 전달해야 IPC 핸들러에서 진행률 이벤트 전송 가능. 기존 `transcode()` 시그니처: `async transcode(filePath, onProgress = null, _options = {})`.
2. **`onPlaylistLoaded`/`onItemSelected` 콜백은 기존 할당을 교체**: app.js:6178과 6199에 이미 할당되어 있으므로, 새 코드가 기존 코드를 **대체**함. 기존 로직(`updatePlaylistUI()` 등)을 새 콜백 안에 포함시켜야 함.
3. **`ffmpegIsAvailable` API는 이미 존재**: preload.js:77에 `ffmpegIsAvailable: () => ipcRenderer.invoke('ffmpeg:is-available')` 정의됨. 새로 추가 불필요.
4. **`preTranscode`/`onPreTranscodeProgress`는 신규 추가**: preload.js에 없으므로 새로 추가 필요.
5. **진행률 수신 방식**: 기존 `ffmpeg:transcode`도 진행률을 `mainWindow.webContents.send()`로 전송하고 renderer에서 `ipcRenderer.on()`으로 수신하는 패턴임 (preload.js:122-124 참고). 사전 변환도 동일 패턴 사용.

### 구현 순서 권장
```
Phase 1 (EBUSY) → Phase 3 (썸네일) → Phase 2 (데이터 소실) → Phase 4 (사전 변환)
```
- Phase 1은 독립적이며 가장 단순 (1파일, 1메서드 추가 + 1곳 교체)
- Phase 3은 1파일만 수정하며 Phase 2와 독립적
- Phase 2는 2파일 수정이지만 복잡도 중간
- Phase 4는 4파일 수정이며 의존성 많음 (마지막에 수행)
