# 첫 공식 사용 핫픽스 - #97 이슈 해결 계획

> GitHub Issue: [#97 배프레임 1차 공식 사용 이후 알려진 이슈](https://github.com/baehandoridori/BAEFRAME/issues/97)
> 작성일: 2026-02-14
> 대상 브랜치: `main` (현재 빌드 버전 기준)

---

## 요약

| # | 항목 | 수정 파일 | 우선순위 | 난이도 | 상태 |
|---|------|----------|---------|--------|------|
| 1 | 텍스트 입력 먹통 | `app.js` | **긴급** | 중간 | ✅ 완료 |
| 2 | 기본 비밀번호 변경 알림 | `app.js` | 높음 | 낮음 | ✅ 완료 |
| 3 | 드로잉 레이어 투명도 UI | `timeline.js`, `drawing-manager.js`, `main.css`, `app.js` | 중간 | 중간 | ✅ 완료 |
| 4 | 타임라인 하이라이트-댓글마커 겹침 | `main.css`, `timeline.js` | 높음 | 낮음 | ✅ 완료 |
| 5 | 줌 스크롤 개선 (긴 영상) | `timeline.js` | 중간 | 중간 | ✅ 완료 |
| 6 | 전체화면 단축키 버튼 숨김 + C키 댓글 | `main.css` | 높음 | 낮음 | ✅ 완료 |

---

## 배경 및 목적

BAEFRAME 1차 공식 사용 후 팀원들로부터 보고된 6개 이슈 (#97) 중 5개에 대한 핫픽스.
실사용 환경에서 발견된 문제들이므로 빠른 해결이 필요하다.

---

## Phase 1: 텍스트 입력 먹통 (긴급)

### 목표
댓글/검색/로그인 등 텍스트 입력 필드에서 간헐적으로 입력이 안 되는 버그 수정

### 증상
- 텍스트 입력란이 가끔 먹통 (커서 깜빡임 자체가 발생하지 않음)
- ESC, TAB 키도 작동하지 않음
- "가끔" 발생하므로 특정 상태 전이 시 포커스가 손실되는 문제로 추정

### 원인 분석

**근본 원인: 여러 UI 상태 전이 시 포커스 관리 부재**

#### 원인 1: 모달/팝업 간 포커스 강탈 (race condition)

**파일: `renderer/scripts/app.js`**

로그인 모달에서 `setTimeout`으로 포커스를 이동하는 패턴이 레이스 컨디션을 유발할 수 있다:

```javascript
// app.js:5501 - setTimeout으로 포커스 이동 → 타이밍 이슈
function openLoginModal(targetName) {
  // ...
  loginModal?.classList.add('active');
  setTimeout(() => loginPasswordInput?.focus(), 100);  // ← 100ms 딜레이
}
```

스레드 팝업도 열릴 때 강제 포커스를 설정한다:

```javascript
// app.js:5993-5994 - 스레드 팝업 열기 시 강제 포커스
function openThreadPopup(markerId) {
  // ...
  threadOverlay.classList.add('open');
  threadEditor.focus();  // ← 강제 포커스 이동
}
```

**문제 시나리오**: 댓글 입력 중 마커 더블클릭 → `openThreadPopup()` 호출 → `threadEditor.focus()` 실행 → 기존 입력 필드(`commentInput`) 포커스 상실 → 팝업 닫은 후 포커스가 어디에도 없는 상태

#### 원인 2: 댓글 모드 자동 해제로 인한 입력 차단

```javascript
// app.js:3706-3710 - 마커 영역 밖 클릭 시 댓글 모드 강제 해제
if (commentManager.pendingMarker && !clickedInsideMarker) {
  commentManager.setCommentMode(false);  // ← 댓글 모드 꺼짐
}
```

댓글 모드가 해제되면 `markerContainer.style.pointerEvents = 'none'`이 되면서, pending 상태의 마커 입력 텍스트가 있던 textarea에 더 이상 도달할 수 없게 된다.

#### 원인 3: 전역 keydown 핸들러의 예외 처리는 되어있으나, 포커스 복원 로직 부재

```javascript
// app.js:4827-4832 - handleKeydown
function handleKeydown(e) {
  if (e.target.tagName === 'TEXTAREA' || e.target.tagName === 'INPUT') return;
  if (e.target.isContentEditable) return;
  if (commentManager.pendingMarker) return;
  // ...
}
```

입력 필드 예외 처리는 올바르게 되어있지만, 문제는 **포커스 자체가 입력 필드에 없을 때** 발생한다. 즉, 사용자가 입력 필드를 클릭해도 포커스가 가지 않는 경우.

### 수정 방안

#### 1-A. 모달 열기 시 이전 포커스 저장 & 복원 메커니즘

```javascript
// app.js에 추가할 포커스 관리 유틸리티
let _previousFocusElement = null;

function saveFocus() {
  _previousFocusElement = document.activeElement;
}

function restoreFocus() {
  if (_previousFocusElement && document.contains(_previousFocusElement)) {
    _previousFocusElement.focus();
    _previousFocusElement = null;
  }
}
```

적용 위치:
- `openThreadPopup()` 시작 부분에 `saveFocus()` 추가
- `closeThreadPopup()` 마지막에 `restoreFocus()` 추가
- `openLoginModal()` 시작에 `saveFocus()` 추가
- `closeLoginModalFn()` 마지막에 `restoreFocus()` 추가

#### 1-B. setTimeout 포커스 제거 → 직접 포커스로 변경

```javascript
// 변경 전 (app.js:5501)
setTimeout(() => loginPasswordInput?.focus(), 100);

// 변경 후 - CSS transition 완료 후 포커스
loginModal?.addEventListener('transitionend', function handler() {
  loginPasswordInput?.focus();
  loginModal?.removeEventListener('transitionend', handler);
}, { once: true });
```

#### 1-C. 댓글 모드 해제 시 pending textarea 보호

```javascript
// app.js:3706-3710 수정
// 변경 전
if (commentManager.pendingMarker && !clickedInsideMarker) {
  commentManager.setCommentMode(false);
}

// 변경 후 - pending 마커의 textarea에 포커스가 있으면 해제하지 않음
if (commentManager.pendingMarker && !clickedInsideMarker) {
  const pendingTextarea = document.querySelector('.pending-marker textarea, .pending-marker input');
  if (pendingTextarea && document.activeElement === pendingTextarea) {
    // 입력 중이므로 모드 해제하지 않음
    return;
  }
  commentManager.setCommentMode(false);
}
```

### 수정 파일

| 파일 | 라인 | 수정 내용 |
|------|------|----------|
| `renderer/scripts/app.js` | 5495-5502 | `openLoginModal()` - setTimeout 제거, saveFocus 추가 |
| `renderer/scripts/app.js` | 5504-5506 | `closeLoginModalFn()` - restoreFocus 추가 |
| `renderer/scripts/app.js` | ~5924-5995 | `openThreadPopup()` - saveFocus 추가 |
| `renderer/scripts/app.js` | `closeThreadPopup()` | restoreFocus 추가 |
| `renderer/scripts/app.js` | 3706-3710 | pending 마커 textarea 포커스 보호 |

### 예상 리스크
- **낮음**: 포커스 저장/복원은 기존 동작에 영향을 주지 않음
- **확인 필요**: `transitionend` 이벤트가 모달 CSS transition과 정확히 매핑되는지 확인 필요. 안전하게 `requestAnimationFrame` 2회 래핑도 고려.

### 테스트 방법
1. 댓글 입력 중 → 비디오 영역 클릭 → 다시 댓글 입력 → 입력 되는지 확인
2. 마커 더블클릭으로 스레드 열기 → 닫기 → 댓글 입력 가능한지 확인
3. 로그인 모달 열기 → 비밀번호 입력 → ESC → 다시 열기 → 입력 되는지 확인
4. pending 마커 텍스트 입력 중 → 마커 밖 클릭 → 입력이 중단되지 않는지 확인

---

## Phase 2: 타임라인 하이라이트-댓글마커 겹침

### 목표
댓글 마커(세로선 + 아이콘)가 하이라이트 바 아래에 가려지지 않도록 수정

### 원인 분석

**핵심 문제: `comment-marker-track`의 `height: 100%`가 `tracksContainer` 전체를 관통**

현재 DOM 구조:
```
tracksContainer (position: relative)
├── highlight-track (24px, position: relative)
│   └── highlight-item (z-index: 10, height: 20px)
├── comment-track (24px, position: relative)
│   └── comment-range-item (z-index: 10)
├── track-row (36px)
│   └── video track clip
└── comment-marker-track (동적 추가, position: absolute, top: 0, height: 100%, z-index: 10)
    ├── ::before (💬 또는 ✓ 아이콘, top: -4px)
    └── (세로선 = background 색상)
```

문제 포인트:
1. `comment-marker-track`은 `position: absolute; top: 0; height: 100%`로 **tracksContainer 전체 높이를 관통**
2. `highlight-item`과 같은 `z-index: 10`이므로 DOM 순서에 따라 겹침 발생
3. 하이라이트가 투명 배경(`rgba(..., 0.3)`)이라 마커 세로선이 비쳐 보이지만, 하이라이트 바가 마커 위에 렌더링되어 아이콘(::before)을 가림

### 수정 방안

**방안: comment-marker-track의 높이를 댓글 트랙 이하 영역으로 제한**

사용자 요구: "하이라이트 바로 밑 댓글 칸까지만 해당되게 해야해"

즉, comment-marker-track의 세로선은 **댓글 트랙(comment-track) 영역부터 아래로만** 표시되어야 한다.

```css
/* 변경 전 (main.css:4105-4115) */
.comment-marker-track {
  position: absolute;
  top: 0;           /* ← tracksContainer 최상단부터 */
  width: 3px;
  height: 100%;     /* ← 전체 높이 */
  z-index: 10;
}

/* 변경 후 */
.comment-marker-track {
  position: absolute;
  top: 0;
  width: 3px;
  height: 100%;
  z-index: 10;
  /* 하이라이트 트랙(24px + 2px margin) 영역은 제외 */
  clip-path: inset(0 0 0 0);  /* 필요 시 조정 */
}
```

**그러나 더 근본적인 해결책은 JS에서 마커의 top/height를 동적으로 계산하는 것:**

`timeline.js`의 `addCommentMarker()` 함수 (라인 1438-1500) 및 `_addClusteredMarker()` 함수에서 마커 생성 시:

```javascript
// timeline.js:1438-1500 addCommentMarker()
// 변경 전
marker.style.left = `${percent}%`;
// (top, height 명시 없음 → CSS 기본값 top: 0, height: 100%)

// 변경 후 - highlight-track이 있으면 그 아래부터 시작
const highlightTrack = document.getElementById('highlightTrack');
const highlightVisible = highlightTrack && highlightTrack.style.display !== 'none';
const topOffset = highlightVisible ? highlightTrack.offsetHeight + 2 : 0;  // 24px + 2px margin

marker.style.top = `${topOffset}px`;
marker.style.height = `calc(100% - ${topOffset}px)`;
```

**그리고 ::before (아이콘)의 top 값도 조정:**

```css
/* 변경 전 */
.comment-marker-track::before {
  top: -4px;  /* 마커 상단 위로 표시 */
}

/* 변경 후 - 마커 시작점 바로 위에 아이콘 표시 */
.comment-marker-track::before {
  top: -4px;  /* 이 값은 유지 (마커 top이 이미 조정됨) */
}
```

**추가로 하이라이트가 토글될 때(표시/숨김) 마커 위치를 다시 계산해야 함:**

`renderHighlights()` 함수 (timeline.js:1756) 호출 후 `_refreshCommentMarkers()` 같은 함수를 호출하여 마커 위치 업데이트.

### 수정 파일

| 파일 | 라인 | 수정 내용 |
|------|------|----------|
| `renderer/scripts/modules/timeline.js` | 1438-1498 | `addCommentMarker()` - top/height 동적 계산 |
| `renderer/scripts/modules/timeline.js` | 1607-1691 | `_addClusteredMarker()` - 동일 수정 |
| `renderer/scripts/modules/timeline.js` | 1756+ | `renderHighlights()` 후 마커 재배치 호출 |
| `renderer/styles/main.css` | 4105-4115 | `.comment-marker-track` 기본 스타일 (필요 시) |

### 대안: CSS-only 접근

마커의 top/height를 JS가 아닌 CSS 변수로 제어:

```css
.tracks-container {
  --marker-top-offset: 0px;  /* JS에서 동적 설정 */
}

.comment-marker-track {
  top: var(--marker-top-offset);
  height: calc(100% - var(--marker-top-offset));
}
```

```javascript
// JS에서 하이라이트 트랙 표시/숨김 시
tracksContainer.style.setProperty(
  '--marker-top-offset',
  highlightVisible ? '26px' : '0px'  // 24px + 2px
);
```

이 방법이 **기존 마커를 모두 재생성할 필요 없으므로 더 효율적**이다.

### 예상 리스크
- **낮음**: CSS 변수 방식은 기존 코드 변경 최소화
- **확인 필요**: comment-track도 표시/숨김에 따라 offset 재계산 필요

### 테스트 방법
1. 하이라이트 있는 영상에서 댓글 마커가 하이라이트 아래로만 표시되는지 확인
2. 하이라이트 없는 영상에서 마커가 정상 표시되는지 확인
3. 하이라이트 추가/삭제 시 마커 위치가 자동 업데이트되는지 확인

---

## Phase 3: 기본 비밀번호 변경 알림

### 목표
기본 비밀번호(`1234`)로 로그인한 사용자에게 비밀번호 변경을 권유하는 알림 표시

### 현재 시스템 분석

이미 구현된 것:
- 기본 비밀번호: `1234` (`auth-manager.js:78`)
- 비밀번호 변경 모달 UI 완성 (`index.html:1128-1154`)
- 비밀번호 변경 함수 완성 (`auth-manager.js:172-199`)
- 토스트 알림 시스템 완성 (`app.js:4752-4767`)

미구현:
- 기본 비밀번호 사용 여부 감지
- 변경 권유 알림

### 수정 방안

#### 3-A. 방법 1: 입력값 직접 비교 (간단)

```javascript
// app.js:5518-5531 doLogin() 함수 수정
async function doLogin() {
  // ...기존 코드...
  try {
    authManager.logout();
    const result = await authManager.login(_loginTargetName, password);
    userSettings.setUserName(_loginTargetName);
    updateUserName(_loginTargetName);

    // === 추가: 기본 비밀번호 경고 ===
    if (password === '1234') {
      showToast(
        '초기 비밀번호로 로그인했습니다. 보안을 위해 비밀번호를 변경해주세요.',
        'warning',
        5000,
        true  // force: 설정과 무관하게 항상 표시
      );
    }
    // === 추가 끝 ===

    showToast(`"${_loginTargetName}"(으)로 로그인했습니다.`, 'success');
    closeLoginModalFn();
  }
}
```

#### 3-B. 방법 2: 해시 비교 (더 안전)

비밀번호 평문을 비교하지 않고, `1234`의 해시값과 저장된 해시값을 비교:

```javascript
// auth-manager.js에 메서드 추가
async isDefaultPassword(name) {
  const user = this._findUser(name);
  if (!user) return false;

  const defaultHash = await this._hashPassword('1234');
  return user.passwordHash === defaultHash;
}
```

```javascript
// app.js doLogin() 수정
const result = await authManager.login(_loginTargetName, password);
// ...

if (await authManager.isDefaultPassword(_loginTargetName)) {
  showToast(
    '초기 비밀번호를 사용 중입니다. 보안을 위해 비밀번호를 변경해주세요.',
    'warning', 5000, true
  );
}
```

**권장: 방법 1 (간단하고 충분)**. 이미 로그인 시점에 평문 비밀번호가 존재하므로 직접 비교해도 보안상 차이 없음.

### 수정 파일

| 파일 | 라인 | 수정 내용 |
|------|------|----------|
| `renderer/scripts/app.js` | 5518-5531 | `doLogin()` 내 기본 비밀번호 체크 추가 |

### 예상 리스크
- **매우 낮음**: 토스트 알림 1줄 추가

### 테스트 방법
1. 기본 비밀번호(`1234`)로 로그인 → 경고 토스트 표시 확인
2. 변경된 비밀번호로 로그인 → 경고 없이 정상 로그인 확인
3. 비보호 사용자(비밀번호 없는 사용자)로 로그인 → 경고 없음 확인

---

## Phase 4: 드로잉 레이어 투명도 UI

### 목표
드로잉 레이어별 불투명도를 조절할 수 있는 UI 컨트롤 추가

### 현재 시스템 분석

이미 구현된 것:
- `DrawingLayer.opacity` 속성 (`drawing-layer.js:95`) - 기본값 1
- JSON 직렬화/역직렬화에 opacity 포함 (`drawing-layer.js:324, 339`)
- 렌더링 시 `globalAlpha` 적용 (`drawing-manager.js:650-683`)
- 브러시/펜 도구의 불투명도 슬라이더 (`app.js:1385-1436`, `index.html:418-421`)

미구현:
- 레이어별 투명도 UI 컨트롤 (슬라이더)
- `drawingManager.setLayerOpacity()` 메서드
- 레이어 헤더에 투명도 표시/조절 UI

### 수정 방안

#### 4-A. DrawingManager에 setLayerOpacity 메서드 추가

```javascript
// drawing-manager.js에 추가
setLayerOpacity(layerId, opacity) {
  const layer = this.layers.find(l => l.id === layerId);
  if (!layer) return;

  layer.opacity = Math.max(0, Math.min(1, opacity));
  this.renderFrame(this.currentFrame);
  this._emit('layersChanged');
  log.debug('레이어 투명도 변경', { layerId, opacity: layer.opacity });
}
```

#### 4-B. 레이어 헤더 UI에 투명도 슬라이더 추가

```javascript
// timeline.js:920-958 _renderLayerHeader() 수정
// 기존 HTML에 투명도 컨트롤 추가

header.innerHTML = `
  <div class="layer-color" style="background: ${layer.color}"></div>
  <span class="layer-visibility" data-action="visibility">
    ${layer.visible ? '👁' : '👁‍🗨'}
  </span>
  <span class="layer-name">${layer.name}</span>
  <!-- 투명도 슬라이더 추가 -->
  <div class="layer-opacity-control">
    <input type="range" class="layer-opacity-slider"
           data-action="opacity"
           min="0" max="100"
           value="${Math.round(layer.opacity * 100)}"
           title="투명도 ${Math.round(layer.opacity * 100)}%">
  </div>
  <span class="layer-lock" data-action="lock">
    ${layer.locked ? '🔒' : ''}
  </span>
`;
```

#### 4-C. 이벤트 핸들러 연결

```javascript
// timeline.js _renderLayerHeader() 내부
header.querySelector('[data-action="opacity"]')?.addEventListener('input', (e) => {
  e.stopPropagation();
  const opacityPercent = parseInt(e.target.value);
  e.target.title = `투명도 ${opacityPercent}%`;
  this._emit('layerOpacityChange', { layerId: layer.id, opacity: opacityPercent / 100 });
});
```

```javascript
// app.js에서 이벤트 수신
timeline.addEventListener('layerOpacityChange', (e) => {
  const { layerId, opacity } = e.detail;
  drawingManager.setLayerOpacity(layerId, opacity);
});
```

#### 4-D. CSS 스타일

```css
/* main.css에 추가 */
.layer-opacity-control {
  display: flex;
  align-items: center;
  flex: 1;
  max-width: 60px;
  margin: 0 4px;
}

.layer-opacity-slider {
  width: 100%;
  height: 3px;
  cursor: pointer;
  accent-color: var(--accent-primary);
}
```

### 수정 파일

| 파일 | 라인 | 수정 내용 |
|------|------|----------|
| `renderer/scripts/modules/drawing-manager.js` | (새 메서드) | `setLayerOpacity()` 추가 |
| `renderer/scripts/modules/timeline.js` | 920-958 | `_renderLayerHeader()` 투명도 슬라이더 추가 |
| `renderer/scripts/app.js` | (이벤트 연결부) | `layerOpacityChange` 이벤트 핸들러 추가 |
| `renderer/styles/main.css` | (레이어 헤더 스타일) | 투명도 슬라이더 CSS 추가 |

### 예상 리스크
- **낮음**: 기존 데이터 모델과 렌더링 로직이 이미 opacity를 지원
- **확인 필요**: 레이어 헤더 영역이 좁으므로 슬라이더가 UI에 잘 맞는지 확인

### 테스트 방법
1. 드로잉 레이어 생성 → 헤더에 투명도 슬라이더 표시되는지 확인
2. 슬라이더 조절 → 캔버스에 투명도가 실시간 반영되는지 확인
3. 투명도 변경 후 저장 → 재로드 → 투명도 유지되는지 확인

---

## Phase 5: 줌 스크롤 개선 (긴 영상)

### 목표
긴 영상에서 과도한 스크롤 없이 원하는 위치로 빠르게 이동할 수 있도록 개선

### 현재 시스템 분석

이미 구현된 것:
- 동적 maxZoom 계산: 영상 프레임 수 기반 (`timeline.js:431-466`)
  - `maxZoom = (targetFrameWidth * totalFrames * 100) / baseContainerWidth`
  - 최대 50,000%까지 지원
- 플레이헤드 중심 줌 (`timeline.js:118-137, 148-179`)
- 자동 스크롤 (`timeline.js:492-537`)
- 줌 인디케이터 표시

현재 줌 동작:
- **기본 휠**: 플레이헤드 중심 줌 인/아웃 (delta = ±15)
- **Shift + 휠**: 레이어 스크롤 (상하)
- **줌 슬라이더**: 좌우 줌 제어

### 문제점

"긴 영상에서 스크롤이 과도하게 필요"하다는 것은:
1. **줌 아웃(100%) 상태에서 원하는 위치로 이동하기 어려움** - 프레임이 너무 작아 정밀 클릭 불가
2. **줌 인 상태에서 먼 위치로 이동 시 스크롤 많이 필요** - 가로 스크롤 없이 줌만 지원
3. **줌 단계(delta=15)가 고정값** - 높은 줌 레벨에서 변화가 미미

### 수정 방안

#### 5-A. 가로 스크롤 지원 (Ctrl + 휠)

현재: 기본 휠 = 줌, Shift + 휠 = 세로 스크롤
제안: **Ctrl + 휠 = 가로 스크롤** 추가

```javascript
// timeline.js:148-179 휠 이벤트 수정
this.timelineTracks?.addEventListener('wheel', (e) => {
  e.preventDefault();

  if (e.shiftKey) {
    // Shift + 휠: 세로 스크롤 (레이어 탐색) - 기존 유지
    this.timelineTracks.scrollTop += e.deltaY;
    if (this.layerHeaders) {
      this.layerHeaders.scrollTop = this.timelineTracks.scrollTop;
    }
  } else if (e.ctrlKey) {
    // === 추가: Ctrl + 휠 = 가로 스크롤 ===
    const scrollAmount = e.deltaY * 3;  // 스크롤 속도 배수
    this.timelineTracks.scrollLeft += scrollAmount;
  } else {
    // 기본 휠: 줌 - 기존 유지
    // ...
  }
}, { passive: false });
```

#### 5-B. 줌 단계를 비율 기반으로 변경

현재 `delta = ±15` 고정값 → 현재 줌 레벨의 비율(예: 5%)로 변경:

```javascript
// 변경 전
const delta = e.deltaY > 0 ? -15 : 15;

// 변경 후 - 현재 줌 레벨의 5% 비율
const zoomPercent = 0.05;  // 5%
const delta = e.deltaY > 0
  ? -(this.zoom * zoomPercent)
  : (this.zoom * zoomPercent);
const newZoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.zoom + delta));
```

이렇게 하면 줌 레벨이 높을수록 줌 변화량도 커져서, **고배율에서 줌 아웃이 매우 빨라진다.**

#### 5-C. 타임라인 클릭으로 해당 시간 이동 (이미 구현 여부 확인 필요)

줌 인 상태에서 타임라인 눈금자(ruler)를 클릭하면 해당 시간으로 바로 이동하는 기능이 있는지 확인하고, 없으면 추가.

### 수정 파일

| 파일 | 라인 | 수정 내용 |
|------|------|----------|
| `renderer/scripts/modules/timeline.js` | 148-179 | 휠 이벤트에 Ctrl+가로스크롤 추가, 줌 delta 비율 기반으로 변경 |

### 예상 리스크
- **낮음**: 기존 줌 동작 유지하면서 새 단축키만 추가
- **확인 필요**: 기존에 Ctrl+휠이 다른 용도로 사용되는지 확인 (현재 미사용)

### 테스트 방법
1. 긴 영상(5분+) 로드 → 줌 인 상태에서 Ctrl+휠로 가로 스크롤 확인
2. 높은 줌 레벨(1000%+)에서 줌 아웃 속도가 적절한지 확인
3. 기존 줌 동작(기본 휠)이 정상 작동하는지 확인

---

## 리스크 및 우려 사항

| 리스크 | 심각도 | 해당 Phase | 완화 방안 |
|--------|--------|-----------|----------|
| 포커스 관리가 다른 입력 필드에 영향 | 중간 | Phase 1 | 모든 입력 필드에서 포커스 이동 테스트 |
| CSS 변수 방식이 IE/구형 브라우저 미지원 | 낮음 | Phase 2 | Electron 28 기반이므로 문제 없음 |
| 레이어 헤더 공간 부족으로 슬라이더 겹침 | 낮음 | Phase 4 | max-width 제한 및 hover 시 확장 고려 |
| 비율 기반 줌이 너무 민감/둔감할 수 있음 | 낮음 | Phase 5 | zoomPercent 값 조정 (3~10% 범위 테스트) |
| `.bframe` 파일 포맷 호환성 | 낮음 | Phase 4 | opacity 필드가 이미 JSON 스키마에 포함되어 있음 |

---

## 구현 순서 (권장)

```
Phase 2 (하이라이트-댓글마커 겹침) → CSS 변경만으로 빠르게 해결 가능
    ↓
Phase 3 (기본 비밀번호 알림) → 3~5줄 추가로 해결
    ↓
Phase 1 (텍스트 입력 먹통) → 가장 긴급하지만 테스트 많이 필요
    ↓
Phase 5 (줌 스크롤 개선) → 기존 동작 수정이므로 신중하게
    ↓
Phase 4 (드로잉 레이어 투명도) → 새 기능 추가이므로 가장 마지막
```

---

## 전체 수정 대상 파일 목록

| 파일 | Phase | 수정 범위 |
|------|-------|----------|
| `renderer/scripts/app.js` | 1, 3 | 포커스 관리, 비밀번호 체크, 이벤트 연결 |
| `renderer/scripts/modules/timeline.js` | 2, 4, 5 | 마커 위치, 레이어 헤더, 줌 로직 |
| `renderer/scripts/modules/drawing-manager.js` | 4 | setLayerOpacity 메서드 |
| `renderer/styles/main.css` | 2, 4 | 마커 스타일, 투명도 슬라이더 |

---

## 참고: 주요 코드 위치 퀵 레퍼런스

### app.js
- `handleKeydown()`: 4827-4832 (전역 키보드 핸들러)
- `showToast()`: 4752-4767 (토스트 알림)
- `openLoginModal()`: 5495-5502 (로그인 모달)
- `doLogin()`: 5509-5541 (로그인 실행)
- `openThreadPopup()`: 5924-5995 (스레드 팝업)
- `doChangePassword()`: 5598-5629 (비밀번호 변경)
- 댓글 모드 해제: 3706-3710
- 도구 불투명도 UI: 1385-1436

### timeline.js
- 줌 상태: 26-35
- 휠 이벤트: 148-179
- `_calculateDynamicMaxZoom()`: 431-466
- `addCommentMarker()`: 1438-1500
- `_addClusteredMarker()`: 1607-1693
- `renderHighlights()`: 1756-1782
- `_createHighlightElement()`: 1789-1832
- `_renderLayerHeader()`: 920-958

### drawing-manager.js
- 레이어 렌더링 (globalAlpha 적용): 650-683
- `_renderFrameSync()`: 669-683
- `setOpacity()`: 796

### auth-manager.js
- `registerUser()` (기본 비밀번호 `1234`): 66-96
- `login()`: 124-154
- `changePassword()`: 172-199
- `_hashPassword()`: 294-300

### main.css
- `.tracks-container`: 1657-1660
- `.highlight-track`: 1849-1856
- `.highlight-item`: 1859-1870
- `.comment-track`: 2106-2110
- `.comment-marker-track`: 4105-4115
- `.comment-marker-track.clustered`: 4153-4180
- 토스트 스타일: 3695-3750
- `.shortcuts-toggle`: 3579-3596
- 전체화면 스타일: 6092-6261

---

## Phase 6: 전체화면 단축키 버튼 숨김 + C키 댓글 모드 (✅ 완료)

### 목표
1. 전체화면에서 단축키 설정 버튼(우하단 키보드 아이콘)을 숨기기
2. 전체화면에서 C키로 댓글/마커 추가 기능이 작동하도록 하기

### 원인 분석

**단축키 버튼 문제:**
- `.shortcuts-toggle` (`index.html:897`)이 `position: fixed; bottom: 16px; right: 16px; z-index: 200`으로 고정
- 전체화면 CSS에서 숨김 처리가 누락되어 있었음

**C키 댓글 모드 문제:**
- `handleKeydown`의 `KeyC` 케이스 (`app.js:4862-4867`)에서 `toggleCommentMode()` 호출은 이미 전체화면에서도 작동
- 하지만 `main.css:6200-6202`에서 `.comment-markers-container`가 `display: none !important`로 숨겨져 있어서, 댓글 모드 진입해도 마커 배치 영역이 보이지 않았음

### 수정 내용 (완료)

**파일: `renderer/styles/main.css` (6200-6210)**

```css
/* 변경 전 */
body.app-fullscreen .comment-markers-container {
  display: none !important;
}

/* 변경 후 */
body.app-fullscreen .comment-markers-container {
  display: none !important;
}

body.app-fullscreen .video-wrapper.comment-mode .comment-markers-container {
  display: block !important;
}

body.app-fullscreen .shortcuts-toggle {
  display: none !important;
}
```

### 동작 원리
- 전체화면 기본 상태: 마커 컨테이너 숨김 + 단축키 버튼 숨김
- C키 누르면: `toggleCommentMode()` → `videoWrapper.classList.add('comment-mode')` → CSS 규칙에 의해 마커 컨테이너 표시
- 다시 C키 또는 ESC: 댓글 모드 해제 → `comment-mode` 클래스 제거 → 마커 컨테이너 다시 숨김

### 테스트 방법
1. F키로 전체화면 진입 → 우하단 단축키 버튼이 사라지는지 확인
2. 전체화면에서 C키 → 댓글 모드 진입 안내 표시 확인
3. 전체화면 댓글 모드에서 화면 클릭 → 마커 위치 지정 가능한지 확인
4. F키로 전체화면 해제 → 단축키 버튼 다시 표시되는지 확인

---

## 핫픽스 적용 기록

> 적용일: 2026-02-16
> 적용 브랜치: `claude/fix-issue-97-hotfix-PMUzk`

### 무엇을 수정했는가

6개 이슈 항목 중 나머지 5개(Phase 1~5)를 모두 수정 완료했다.

| Phase | 수정 내용 | 수정 파일 |
|-------|----------|----------|
| 1 | 텍스트 입력 먹통 - 포커스 관리 개선 | `app.js` |
| 2 | 타임라인 하이라이트-댓글마커 겹침 | `main.css`, `timeline.js` |
| 3 | 기본 비밀번호(1234) 변경 알림 | `app.js` |
| 4 | 드로잉 레이어 투명도 UI | `drawing-manager.js`, `timeline.js`, `app.js`, `main.css` |
| 5 | 줌 스크롤 개선 (긴 영상) | `timeline.js` |

### 어떻게 수정했는가

#### Phase 1: 텍스트 입력 먹통

**근본 원인**: 모달/팝업 간 포커스 전환 시 이전 포커스를 저장하지 않아, 팝업을 닫은 후 포커스가 유실되는 문제.

**수정 방법**:
1. **포커스 저장/복원 유틸리티** 추가 (`saveFocus()`, `restoreFocus()`)
   - `_previousFocusElement` 변수에 현재 포커스를 저장하고, 팝업 닫을 때 복원
2. **로그인 모달**: `openLoginModal()`에서 `saveFocus()` 호출, `closeLoginModalFn()`에서 `restoreFocus()` 호출
   - `setTimeout` 기반 포커스 이동을 `transitionend` 이벤트 + `requestAnimationFrame` 폴백으로 교체하여 레이스 컨디션 제거
3. **스레드 팝업**: `openThreadPopup()`에서 `saveFocus()`, `closeThreadPopup()`에서 `restoreFocus()` 호출
4. **pending 마커 보호**: `blur` 이벤트 핸들러에서 포커스가 마커 내 입력 필드로 이동한 경우 댓글 모드 해제를 차단

#### Phase 2: 타임라인 하이라이트-댓글마커 겹침

**근본 원인**: `comment-marker-track`이 `top: 0; height: 100%`로 tracksContainer 전체를 관통하여 하이라이트 트랙(24px) 영역에서 마커가 겹침.

**수정 방법**:
1. **CSS 변수 방식 채택**: `.tracks-container`에 `--marker-top-offset` CSS 변수를 정의
2. `.comment-marker-track`의 `top`과 `height`를 CSS 변수로 제어: `top: var(--marker-top-offset); height: calc(100% - var(--marker-top-offset))`
3. `renderHighlights()`에서 하이라이트 유무에 따라 `--marker-top-offset`을 `26px` 또는 `0px`으로 동적 설정
4. 기존 마커를 재생성할 필요 없이 CSS 변수 하나로 모든 마커 위치가 자동 반영됨

#### Phase 3: 기본 비밀번호 변경 알림

**수정 방법**:
- `doLogin()` 함수에서 로그인 성공 후 `password === '1234'` 체크
- 기본 비밀번호 사용 시 `showToast()`로 경고 토스트 표시 (5초간, force 옵션으로 설정 무관하게 표시)

#### Phase 4: 드로잉 레이어 투명도 UI

**수정 방법**:
1. `drawing-manager.js`에 `setLayerOpacity(layerId, opacity)` 메서드 추가
   - 레이어의 `opacity`를 0~1 범위로 설정하고 즉시 렌더링 반영
2. `timeline.js`의 `_renderLayerHeader()`에 투명도 슬라이더(`<input type="range">`) 추가
   - `input` 이벤트로 실시간 투명도 변경, `layerOpacityChange` 커스텀 이벤트 발생
3. `app.js`에서 `layerOpacityChange` 이벤트를 수신하여 `drawingManager.setLayerOpacity()` 호출
4. `main.css`에 `.layer-opacity-control`, `.layer-opacity-slider` 스타일 추가

#### Phase 5: 줌 스크롤 개선

**수정 방법**:
1. **Ctrl + 휠 가로 스크롤** 추가: 줌 인 상태에서 먼 위치로 이동할 때 스크롤 양 = `deltaY * 3`
2. **비율 기반 줌 단계**: 고정값 `±15`에서 `현재 줌의 5%`로 변경 (최소 15 보장)
   - 저배율(100~300%)에서는 기존과 유사한 느낌
   - 고배율(1000%+)에서는 줌 아웃 속도가 비례적으로 증가하여 빠르게 전체 뷰로 돌아갈 수 있음

### 왜 이렇게 수정했는가

1. **포커스 관리(Phase 1)**: `setTimeout`은 타이밍 의존적이라 레이스 컨디션이 발생할 수 있다. `transitionend` + `requestAnimationFrame` 폴백은 CSS 애니메이션 완료 시점에 정확히 포커스를 이동하므로 더 안정적이다. 포커스 저장/복원 패턴은 WAI-ARIA 모달 접근성 가이드라인의 권장 방식이다.

2. **CSS 변수(Phase 2)**: JS에서 개별 마커를 순회하며 스타일을 변경하는 것보다, CSS 변수 하나로 모든 마커에 일괄 적용하는 것이 성능과 유지보수 면에서 우수하다. 마커가 동적으로 추가/제거되어도 추가 코드가 필요 없다.

3. **평문 비교(Phase 3)**: 로그인 시점에 이미 평문 비밀번호가 존재하므로 해시 비교 대비 구현이 간단하면서 보안상 차이가 없다.

4. **기존 데이터 모델 활용(Phase 4)**: `DrawingLayer.opacity` 속성과 렌더링 시 `globalAlpha` 적용이 이미 구현되어 있었으므로, UI 컨트롤만 추가하면 되는 상황이었다.

5. **비율 기반 줌(Phase 5)**: 고정 delta는 줌 레벨에 관계없이 동일한 절대값으로 변하므로, 고배율에서는 미세한 변화만 느껴지고 저배율에서는 과도한 변화가 발생한다. 비율 기반은 모든 줌 레벨에서 일관된 체감 변화를 제공한다.
