# 재생목록(Playlist) 기능 구현 계획

> 여러 영상을 묶어서 한 번에 공유하는 기능

---

## 요약

| Phase | 항목 | 수정 파일 | 이유 | 우선순위 | 상태 |
|-------|------|----------|------|---------|------|
| 1 | 스키마 및 데이터 구조 | shared/schema.js, new: playlist-schema.js | .bplaylist 파일 포맷 정의 | 높음 | ⬜ 대기 |
| 2 | 썸네일 캐시 시스템 | main/ipc-handlers.js, review-data-manager.js | 영상 열 때 자동 썸네일 생성 | 높음 | ⬜ 대기 |
| 3 | 기본 UI (좌측 사이드바) | index.html, main.css, new: playlist-panel.css | 재생목록 패널 기본 구조 | 높음 | ⬜ 대기 |
| 4 | 재생목록 매니저 모듈 | new: playlist-manager.js | 재생목록 CRUD, 파일 I/O | 높음 | ⬜ 대기 |
| 5 | 파일 추가/제거 기능 | playlist-manager.js, app.js | 드래그 앤 드롭, 파일 선택 | 높음 | ⬜ 대기 |
| 6 | 재생 네비게이션 | playlist-manager.js, app.js | 이전/다음 영상, 자동 재생 | 높음 | ⬜ 대기 |
| 7 | 피드백 완료율 표시 | playlist-manager.js, playlist-panel.css | resolved 댓글 비율 계산 | 중간 | ⬜ 대기 |
| 8 | 드래그 순서 변경 | playlist-manager.js | 리스트 재정렬 | 중간 | ⬜ 대기 |
| 9 | 링크 공유 기능 | main/index.js, ipc-handlers.js, app.js | baeframe://playlist 프로토콜 | 높음 | ⬜ 대기 |
| 10 | 플로팅 모드 UI | playlist-panel.css, playlist-manager.js | 사이드바 ↔ 플로팅 토글 | 낮음 | ⬜ 대기 |
| 11 | 실시간 동기화 | new: playlist-collaboration.js | .bplaylist.collab 협업 | 중간 | ⬜ 대기 |
| 12 | 미니 인디케이터 | index.html, main.css, app.js | 헤더에 진행 상황 표시 | 낮음 | ⬜ 대기 |

---

## 배경 및 목적

### 문제
- 10개의 씬을 피드백 받을 때, Slack에 링크 10개를 붙여넣기 해야 함
- 받는 사람도 10개 링크를 하나씩 클릭해야 함
- 어떤 영상까지 봤는지, 전체 진행률 파악이 어려움

### 목표
- 여러 영상을 **재생목록**으로 묶어서 **단일 링크**로 공유
- 받는 사람이 재생목록을 열면 모든 영상을 순차적으로 리뷰 가능
- 전체 피드백 완료율 및 개별 영상 상태 한눈에 파악

### 핵심 사용 시나리오
```
1. A: 10개 영상 작업 완료
2. A: 배프레임에서 "새 재생목록" 생성
3. A: 10개 영상 파일을 드래그 앤 드롭으로 추가
4. A: 재생목록 이름 "EP01 최종 리뷰" 설정
5. A: 재생목록 링크 복사 → Slack에 공유
6. B: 링크 클릭 → 배프레임에서 재생목록 열림
7. B: 순차적으로 리뷰, 피드백 작성
8. A/B: 전체 진행률 실시간 확인
```

---

## Phase 1: 스키마 및 데이터 구조

### 목표
`.bplaylist` 파일 포맷 정의

### 신규 파일
- `shared/playlist-schema.js`

### .bplaylist 스키마 (v1.0)

```javascript
/**
 * @typedef {Object} PlaylistItem
 * @property {string} id - 고유 ID (item_timestamp_random)
 * @property {string} videoPath - 영상 파일 전체 경로
 * @property {string} bframePath - .bframe 파일 경로 (없으면 빈 문자열)
 * @property {string} fileName - 표시용 파일명
 * @property {string} thumbnailPath - 썸네일 캐시 경로
 * @property {number} order - 정렬 순서 (0부터 시작)
 * @property {string} addedAt - 추가 시각 (ISO 8601)
 */

/**
 * @typedef {Object} PlaylistData
 * @property {string} playlistVersion - 스키마 버전 ("1.0")
 * @property {string} name - 재생목록 이름
 * @property {string} id - 재생목록 고유 ID
 * @property {string} createdAt - 생성 시각 (ISO 8601)
 * @property {string} modifiedAt - 수정 시각 (ISO 8601)
 * @property {string} createdBy - 생성자 이름
 * @property {string} createdById - 생성자 ID
 * @property {Array<PlaylistItem>} items - 재생목록 항목들 (최대 50개)
 * @property {Object} settings - 재생목록 설정
 * @property {boolean} settings.autoPlay - 자동 재생 여부
 * @property {boolean} settings.floatingMode - 플로팅 모드 여부
 */
```

### 예시 .bplaylist 파일

```json
{
  "playlistVersion": "1.0",
  "name": "EP01 최종 리뷰",
  "id": "playlist_1706123456789_abc123",
  "createdAt": "2024-01-24T10:00:00Z",
  "modifiedAt": "2024-01-24T12:30:00Z",
  "createdBy": "윤성원",
  "createdById": "yoon",
  "items": [
    {
      "id": "item_1706123456790_def456",
      "videoPath": "G:/Drive/프로젝트/EP01/shot_001.mp4",
      "bframePath": "G:/Drive/프로젝트/EP01/shot_001.bframe",
      "fileName": "shot_001.mp4",
      "thumbnailPath": "%APPDATA%/baeframe/thumbnails/abc123.jpg",
      "order": 0,
      "addedAt": "2024-01-24T10:00:00Z"
    },
    {
      "id": "item_1706123456791_ghi789",
      "videoPath": "G:/Drive/프로젝트/EP01/shot_002.mp4",
      "bframePath": "G:/Drive/프로젝트/EP01/shot_002.bframe",
      "fileName": "shot_002.mp4",
      "thumbnailPath": "%APPDATA%/baeframe/thumbnails/def456.jpg",
      "order": 1,
      "addedAt": "2024-01-24T10:01:00Z"
    }
  ],
  "settings": {
    "autoPlay": false,
    "floatingMode": false
  }
}
```

### 저장 위치
- 재생목록 파일은 **첫 번째 영상과 같은 폴더**에 저장
- 파일명: `{재생목록이름}.bplaylist`
- 예: `G:/Drive/프로젝트/EP01/EP01_최종_리뷰.bplaylist`

### 구현 내용

```javascript
// shared/playlist-schema.js

export const PLAYLIST_VERSION = '1.0';
export const MAX_PLAYLIST_ITEMS = 50;

export function createDefaultPlaylistData(options = {}) {
  const now = new Date().toISOString();
  return {
    playlistVersion: PLAYLIST_VERSION,
    name: options.name || '새 재생목록',
    id: generatePlaylistId(),
    createdAt: now,
    modifiedAt: now,
    createdBy: options.userName || '',
    createdById: options.userId || '',
    items: [],
    settings: {
      autoPlay: false,
      floatingMode: false
    }
  };
}

export function createPlaylistItem(videoPath, bframePath = '') {
  const fileName = extractFileName(videoPath);
  return {
    id: generateItemId(),
    videoPath,
    bframePath,
    fileName,
    thumbnailPath: '',
    order: 0,
    addedAt: new Date().toISOString()
  };
}

export function validatePlaylistData(data) {
  // 필수 필드 검증
  // 버전 호환성 검증
  // 아이템 개수 제한 검증
}
```

### 예상 리스크
- **파일명 충돌**: 같은 이름의 재생목록이 이미 있을 경우 → 숫자 접미사 추가 (예: `리뷰_2.bplaylist`)

---

## Phase 2: 썸네일 캐시 시스템

### 목표
영상 파일을 처음 열 때 자동으로 썸네일 생성 및 캐시

### 수정 파일
- `main/ipc-handlers.js` - 썸네일 생성 IPC 핸들러
- `renderer/scripts/modules/review-data-manager.js` - 영상 로드 시 썸네일 트리거

### 썸네일 저장 경로
```
%APPDATA%/baeframe/thumbnails/
├── {videoPath_hash}_thumb.jpg    // 160x90 (16:9)
└── ...
```

### IPC 핸들러 추가

```javascript
// main/ipc-handlers.js

ipcMain.handle('thumbnail:generate', async (event, videoPath) => {
  const hash = createPathHash(videoPath);
  const thumbPath = path.join(app.getPath('userData'), 'thumbnails', `${hash}_thumb.jpg`);

  // 이미 존재하면 경로만 반환
  if (fs.existsSync(thumbPath)) {
    return { success: true, path: thumbPath };
  }

  // ffmpeg로 첫 프레임 추출 (mpv/ffmpeg.exe 활용)
  try {
    await extractThumbnail(videoPath, thumbPath);
    return { success: true, path: thumbPath };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

ipcMain.handle('thumbnail:get', async (event, videoPath) => {
  const hash = createPathHash(videoPath);
  const thumbPath = path.join(app.getPath('userData'), 'thumbnails', `${hash}_thumb.jpg`);

  if (fs.existsSync(thumbPath)) {
    return { exists: true, path: thumbPath };
  }
  return { exists: false, path: null };
});
```

### ffmpeg 썸네일 추출

```javascript
async function extractThumbnail(videoPath, outputPath) {
  const ffmpegPath = path.join(__dirname, '../mpv/ffmpeg.exe');

  return new Promise((resolve, reject) => {
    const args = [
      '-i', videoPath,
      '-ss', '00:00:00.000',  // 첫 프레임
      '-vframes', '1',
      '-vf', 'scale=160:90:force_original_aspect_ratio=decrease,pad=160:90:(ow-iw)/2:(oh-ih)/2',
      '-q:v', '2',
      outputPath
    ];

    const proc = spawn(ffmpegPath, args);
    proc.on('close', (code) => {
      if (code === 0) resolve();
      else reject(new Error(`ffmpeg exited with code ${code}`));
    });
  });
}
```

### 영상 로드 시 자동 트리거

```javascript
// review-data-manager.js 또는 app.js

async function onVideoLoaded(videoPath) {
  // 기존 로직...

  // 썸네일 생성 (백그라운드)
  window.electronAPI.generateThumbnail(videoPath).catch(console.warn);
}
```

### 예상 리스크
- **ffmpeg 없는 환경**: mpv 폴더에 ffmpeg.exe가 없으면 실패 → 플레이스홀더 이미지 사용
- **대용량 영상**: 썸네일 생성에 시간 소요 → 비동기 처리, 로딩 스피너

---

## Phase 3: 기본 UI (좌측 사이드바)

### 목표
재생목록 패널의 기본 HTML/CSS 구조 구현

### 수정 파일
- `renderer/index.html` - 좌측 사이드바 추가
- `renderer/styles/main.css` - 레이아웃 조정
- `renderer/styles/playlist-panel.css` (신규) - 재생목록 전용 스타일

### HTML 구조

```html
<!-- index.html - main-container 내부 -->

<div class="main-container">
  <!-- 재생목록 사이드바 (좌측) -->
  <aside class="playlist-sidebar" id="playlistSidebar">
    <div class="playlist-header">
      <div class="playlist-title-section">
        <svg class="playlist-icon" viewBox="0 0 24 24"><!-- 리스트 아이콘 --></svg>
        <input type="text" class="playlist-name-input" id="playlistNameInput"
               placeholder="재생목록 이름" value="새 재생목록">
      </div>
      <div class="playlist-actions">
        <button class="playlist-btn" id="btnPlaylistAdd" title="파일 추가">
          <svg viewBox="0 0 24 24"><!-- + 아이콘 --></svg>
        </button>
        <button class="playlist-btn" id="btnPlaylistCopyLink" title="링크 복사">
          <svg viewBox="0 0 24 24"><!-- 링크 아이콘 --></svg>
        </button>
        <button class="playlist-btn" id="btnPlaylistSettings" title="설정">
          <svg viewBox="0 0 24 24"><!-- 설정 아이콘 --></svg>
        </button>
        <button class="playlist-btn" id="btnPlaylistClose" title="닫기">
          <svg viewBox="0 0 24 24"><!-- X 아이콘 --></svg>
        </button>
      </div>
    </div>

    <div class="playlist-progress-bar">
      <div class="playlist-progress-fill" id="playlistProgressFill"></div>
      <span class="playlist-progress-text" id="playlistProgressText">0/0 완료</span>
    </div>

    <div class="playlist-controls">
      <button class="playlist-nav-btn" id="btnPlaylistPrev" title="이전 영상">
        <svg viewBox="0 0 24 24"><!-- ◀◀ 아이콘 --></svg>
      </button>
      <span class="playlist-position" id="playlistPosition">1 / 10</span>
      <button class="playlist-nav-btn" id="btnPlaylistNext" title="다음 영상">
        <svg viewBox="0 0 24 24"><!-- ▶▶ 아이콘 --></svg>
      </button>
      <label class="playlist-autoplay-toggle">
        <input type="checkbox" id="playlistAutoPlay">
        <span>자동 재생</span>
      </label>
    </div>

    <div class="playlist-items" id="playlistItems">
      <!-- 재생목록 아이템들이 여기에 렌더링됨 -->
    </div>

    <div class="playlist-dropzone" id="playlistDropzone">
      <svg viewBox="0 0 24 24"><!-- 업로드 아이콘 --></svg>
      <span>파일을 여기에 드롭하세요</span>
    </div>
  </aside>

  <!-- 사이드바 리사이저 -->
  <div class="playlist-resizer" id="playlistResizer"></div>

  <!-- 기존 viewer-section -->
  <div class="viewer-section" id="viewerSection">
    ...
  </div>
</div>
```

### 재생목록 아이템 템플릿

```html
<div class="playlist-item" data-id="{item.id}" draggable="true">
  <div class="playlist-item-drag-handle">
    <svg viewBox="0 0 24 24"><!-- 드래그 핸들 --></svg>
  </div>
  <div class="playlist-item-thumbnail">
    <img src="{thumbnailPath}" alt="">
    <div class="playlist-item-duration">00:30</div>
  </div>
  <div class="playlist-item-info">
    <div class="playlist-item-name">{fileName}</div>
    <div class="playlist-item-stats">
      <span class="playlist-item-comments">
        <svg><!-- 댓글 아이콘 --></svg>
        12
      </span>
      <span class="playlist-item-progress">
        <div class="mini-progress-bar">
          <div class="mini-progress-fill" style="width: 75%"></div>
        </div>
        75%
      </span>
    </div>
  </div>
  <button class="playlist-item-remove" title="제거">
    <svg viewBox="0 0 24 24"><!-- X 아이콘 --></svg>
  </button>
</div>
```

### CSS 변수 추가

```css
/* main.css :root에 추가 */
:root {
  /* 기존 변수들... */

  /* 재생목록 */
  --playlist-width: 280px;
  --playlist-width-min: 240px;
  --playlist-width-max: 400px;
  --playlist-item-height: 72px;
}
```

### 레이아웃 조정

```css
/* 메인 컨테이너 수정 */
.main-container {
  display: flex;
  height: calc(100vh - var(--header-height));
}

/* 재생목록 사이드바 */
.playlist-sidebar {
  width: var(--playlist-width);
  min-width: var(--playlist-width-min);
  max-width: var(--playlist-width-max);
  background: var(--bg-secondary);
  border-right: 1px solid var(--border-subtle);
  display: flex;
  flex-direction: column;
  transition: width var(--transition-normal);
}

.playlist-sidebar.hidden {
  width: 0;
  min-width: 0;
  overflow: hidden;
  border-right: none;
}

/* 리사이저 */
.playlist-resizer {
  width: 4px;
  cursor: col-resize;
  background: transparent;
  transition: background var(--transition-fast);
}

.playlist-resizer:hover,
.playlist-resizer.active {
  background: var(--accent-primary);
}
```

### 예상 리스크
- **기존 레이아웃 깨짐**: main-container 구조 변경으로 기존 뷰어 영역 영향 → 충분한 테스트 필요
- **반응형 대응**: 화면이 좁을 때 사이드바 자동 숨김 고려

---

## Phase 4: 재생목록 매니저 모듈

### 목표
재생목록 CRUD 및 파일 I/O 로직

### 신규 파일
- `renderer/scripts/modules/playlist-manager.js`

### 클래스 구조

```javascript
// playlist-manager.js

import {
  createDefaultPlaylistData,
  createPlaylistItem,
  validatePlaylistData,
  MAX_PLAYLIST_ITEMS
} from '../../../shared/playlist-schema.js';

export class PlaylistManager {
  constructor() {
    this.currentPlaylist = null;      // 현재 열린 재생목록 데이터
    this.playlistPath = null;         // 현재 재생목록 파일 경로
    this.currentIndex = -1;           // 현재 재생 중인 아이템 인덱스
    this.isModified = false;          // 변경 여부
    this.autoSaveTimer = null;

    // 이벤트 콜백
    this.onPlaylistLoaded = null;     // (playlist) => {}
    this.onItemSelected = null;       // (item, index) => {}
    this.onPlaylistModified = null;   // () => {}
    this.onError = null;              // (error) => {}
  }

  // ========================================
  // 재생목록 생성/열기/저장
  // ========================================

  /**
   * 새 재생목록 생성
   */
  createNew(name = '새 재생목록') {
    this.currentPlaylist = createDefaultPlaylistData({
      name,
      userName: window.appState?.userName || '',
      userId: window.appState?.sessionId || ''
    });
    this.playlistPath = null;
    this.currentIndex = -1;
    this.isModified = true;

    this.onPlaylistLoaded?.(this.currentPlaylist);
    return this.currentPlaylist;
  }

  /**
   * 기존 재생목록 파일 열기
   */
  async open(filePath) {
    try {
      const data = await window.electronAPI.readPlaylist(filePath);

      if (!validatePlaylistData(data)) {
        throw new Error('유효하지 않은 재생목록 파일입니다.');
      }

      this.currentPlaylist = data;
      this.playlistPath = filePath;
      this.currentIndex = data.items.length > 0 ? 0 : -1;
      this.isModified = false;

      // 썸네일 경로 검증 및 재생성
      await this._validateThumbnails();

      this.onPlaylistLoaded?.(this.currentPlaylist);
      return this.currentPlaylist;

    } catch (error) {
      this.onError?.(error);
      throw error;
    }
  }

  /**
   * 재생목록 저장
   */
  async save(savePath = null) {
    if (!this.currentPlaylist) return false;

    const targetPath = savePath || this.playlistPath;

    if (!targetPath) {
      // 새 재생목록: 첫 번째 아이템의 폴더에 저장
      if (this.currentPlaylist.items.length === 0) {
        throw new Error('저장할 아이템이 없습니다.');
      }

      const firstItemPath = this.currentPlaylist.items[0].videoPath;
      const folderPath = window.electronAPI.dirname(firstItemPath);
      const fileName = this._sanitizeFileName(this.currentPlaylist.name);
      this.playlistPath = `${folderPath}/${fileName}.bplaylist`;
    }

    this.currentPlaylist.modifiedAt = new Date().toISOString();

    await window.electronAPI.writePlaylist(this.playlistPath, this.currentPlaylist);
    this.isModified = false;

    return true;
  }

  // ========================================
  // 아이템 관리
  // ========================================

  /**
   * 아이템 추가
   */
  async addItems(filePaths) {
    if (!this.currentPlaylist) {
      this.createNew();
    }

    const currentCount = this.currentPlaylist.items.length;
    const availableSlots = MAX_PLAYLIST_ITEMS - currentCount;

    if (availableSlots <= 0) {
      throw new Error(`재생목록은 최대 ${MAX_PLAYLIST_ITEMS}개까지 추가할 수 있습니다.`);
    }

    const pathsToAdd = filePaths.slice(0, availableSlots);
    const addedItems = [];

    for (const filePath of pathsToAdd) {
      // 영상 파일인지 확인
      if (!this._isVideoFile(filePath)) continue;

      // 중복 확인
      if (this._isDuplicate(filePath)) continue;

      // .bframe 파일 경로 추론
      const bframePath = await this._findBframePath(filePath);

      // 썸네일 생성
      const thumbnailResult = await window.electronAPI.generateThumbnail(filePath);

      const item = createPlaylistItem(filePath, bframePath);
      item.order = this.currentPlaylist.items.length;
      item.thumbnailPath = thumbnailResult.success ? thumbnailResult.path : '';

      this.currentPlaylist.items.push(item);
      addedItems.push(item);
    }

    if (addedItems.length > 0) {
      this.isModified = true;
      this.onPlaylistModified?.();

      // 첫 번째 아이템이면 자동 선택
      if (this.currentIndex === -1) {
        this.selectItem(0);
      }
    }

    return addedItems;
  }

  /**
   * 아이템 제거
   */
  removeItem(itemId) {
    if (!this.currentPlaylist) return;

    const index = this.currentPlaylist.items.findIndex(item => item.id === itemId);
    if (index === -1) return;

    this.currentPlaylist.items.splice(index, 1);

    // order 재정렬
    this.currentPlaylist.items.forEach((item, i) => {
      item.order = i;
    });

    // 현재 인덱스 조정
    if (this.currentIndex >= this.currentPlaylist.items.length) {
      this.currentIndex = this.currentPlaylist.items.length - 1;
    }

    this.isModified = true;
    this.onPlaylistModified?.();
  }

  /**
   * 아이템 순서 변경
   */
  reorderItem(fromIndex, toIndex) {
    if (!this.currentPlaylist) return;

    const items = this.currentPlaylist.items;
    const [moved] = items.splice(fromIndex, 1);
    items.splice(toIndex, 0, moved);

    // order 재정렬
    items.forEach((item, i) => {
      item.order = i;
    });

    // 현재 인덱스 조정
    if (this.currentIndex === fromIndex) {
      this.currentIndex = toIndex;
    } else if (fromIndex < this.currentIndex && toIndex >= this.currentIndex) {
      this.currentIndex--;
    } else if (fromIndex > this.currentIndex && toIndex <= this.currentIndex) {
      this.currentIndex++;
    }

    this.isModified = true;
    this.onPlaylistModified?.();
  }

  // ========================================
  // 재생 네비게이션
  // ========================================

  /**
   * 특정 아이템 선택
   */
  selectItem(index) {
    if (!this.currentPlaylist || index < 0 || index >= this.currentPlaylist.items.length) {
      return null;
    }

    this.currentIndex = index;
    const item = this.currentPlaylist.items[index];

    this.onItemSelected?.(item, index);
    return item;
  }

  /**
   * 다음 아이템으로 이동
   */
  next() {
    if (this.currentIndex < this.currentPlaylist.items.length - 1) {
      return this.selectItem(this.currentIndex + 1);
    }
    return null;
  }

  /**
   * 이전 아이템으로 이동
   */
  prev() {
    if (this.currentIndex > 0) {
      return this.selectItem(this.currentIndex - 1);
    }
    return null;
  }

  /**
   * 현재 아이템 가져오기
   */
  getCurrentItem() {
    if (!this.currentPlaylist || this.currentIndex === -1) {
      return null;
    }
    return this.currentPlaylist.items[this.currentIndex];
  }

  // ========================================
  // 피드백 완료율 계산
  // ========================================

  /**
   * 개별 아이템의 피드백 완료율 계산
   * @param {string} bframePath - .bframe 파일 경로
   * @returns {Object} { total: number, resolved: number, percent: number }
   */
  async getItemProgress(bframePath) {
    if (!bframePath) {
      return { total: 0, resolved: 0, percent: 0 };
    }

    try {
      const bframeData = await window.electronAPI.readBframeFile(bframePath);

      let total = 0;
      let resolved = 0;

      if (bframeData?.comments?.layers) {
        for (const layer of bframeData.comments.layers) {
          for (const marker of layer.markers || []) {
            total++;
            if (marker.resolved) resolved++;
          }
        }
      }

      const percent = total > 0 ? Math.round((resolved / total) * 100) : 0;
      return { total, resolved, percent };

    } catch (error) {
      return { total: 0, resolved: 0, percent: 0 };
    }
  }

  /**
   * 전체 재생목록 피드백 완료율 계산
   */
  async getTotalProgress() {
    if (!this.currentPlaylist) {
      return { total: 0, resolved: 0, percent: 0 };
    }

    let totalMarkers = 0;
    let resolvedMarkers = 0;

    for (const item of this.currentPlaylist.items) {
      const progress = await this.getItemProgress(item.bframePath);
      totalMarkers += progress.total;
      resolvedMarkers += progress.resolved;
    }

    const percent = totalMarkers > 0 ? Math.round((resolvedMarkers / totalMarkers) * 100) : 0;
    return { total: totalMarkers, resolved: resolvedMarkers, percent };
  }

  // ========================================
  // 유틸리티 (private)
  // ========================================

  _isVideoFile(filePath) {
    const ext = filePath.toLowerCase().slice(filePath.lastIndexOf('.'));
    return ['.mp4', '.mov', '.avi', '.mkv', '.webm'].includes(ext);
  }

  _isDuplicate(videoPath) {
    return this.currentPlaylist.items.some(item => item.videoPath === videoPath);
  }

  async _findBframePath(videoPath) {
    const basePath = videoPath.replace(/\.[^/.]+$/, '');
    const bframePath = `${basePath}.bframe`;

    const exists = await window.electronAPI.fileExists(bframePath);
    return exists ? bframePath : '';
  }

  _sanitizeFileName(name) {
    return name.replace(/[<>:"/\\|?*]/g, '_').trim() || '재생목록';
  }

  async _validateThumbnails() {
    for (const item of this.currentPlaylist.items) {
      if (item.thumbnailPath) {
        const exists = await window.electronAPI.fileExists(item.thumbnailPath);
        if (!exists) {
          const result = await window.electronAPI.generateThumbnail(item.videoPath);
          item.thumbnailPath = result.success ? result.path : '';
        }
      }
    }
  }

  // ========================================
  // 설정
  // ========================================

  setAutoPlay(enabled) {
    if (this.currentPlaylist) {
      this.currentPlaylist.settings.autoPlay = enabled;
      this.isModified = true;
    }
  }

  setFloatingMode(enabled) {
    if (this.currentPlaylist) {
      this.currentPlaylist.settings.floatingMode = enabled;
      this.isModified = true;
    }
  }

  setName(name) {
    if (this.currentPlaylist) {
      this.currentPlaylist.name = name;
      this.isModified = true;
      this.onPlaylistModified?.();
    }
  }

  // ========================================
  // 정리
  // ========================================

  close() {
    this.currentPlaylist = null;
    this.playlistPath = null;
    this.currentIndex = -1;
    this.isModified = false;
  }
}

export default PlaylistManager;
```

---

## Phase 5: 파일 추가/제거 기능

### 목표
드래그 앤 드롭 및 파일 선택 다이얼로그로 파일 추가

### 수정 파일
- `renderer/scripts/modules/playlist-manager.js` (위에서 구현)
- `renderer/scripts/app.js` - UI 이벤트 연결
- `main/ipc-handlers.js` - 파일 다이얼로그

### 드래그 앤 드롭 구현

```javascript
// app.js

function initPlaylistDragDrop() {
  const dropzone = document.getElementById('playlistDropzone');
  const sidebar = document.getElementById('playlistSidebar');

  // 드래그 진입
  sidebar.addEventListener('dragenter', (e) => {
    e.preventDefault();
    dropzone.classList.add('active');
  });

  // 드래그 이탈
  sidebar.addEventListener('dragleave', (e) => {
    if (!sidebar.contains(e.relatedTarget)) {
      dropzone.classList.remove('active');
    }
  });

  // 드래그 오버
  sidebar.addEventListener('dragover', (e) => {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'copy';
  });

  // 드롭
  sidebar.addEventListener('drop', async (e) => {
    e.preventDefault();
    dropzone.classList.remove('active');

    const files = Array.from(e.dataTransfer.files);
    const videoPaths = files
      .filter(f => playlistManager._isVideoFile(f.path))
      .map(f => f.path);

    if (videoPaths.length > 0) {
      try {
        await playlistManager.addItems(videoPaths);
        renderPlaylistItems();
      } catch (error) {
        showToast(error.message, 'error');
      }
    }
  });
}

// 파일 선택 버튼
document.getElementById('btnPlaylistAdd').addEventListener('click', async () => {
  const result = await window.electronAPI.showOpenDialog({
    title: '재생목록에 추가할 영상 선택',
    filters: [
      { name: '비디오 파일', extensions: ['mp4', 'mov', 'avi', 'mkv', 'webm'] }
    ],
    properties: ['openFile', 'multiSelections']
  });

  if (!result.canceled && result.filePaths.length > 0) {
    try {
      await playlistManager.addItems(result.filePaths);
      renderPlaylistItems();
    } catch (error) {
      showToast(error.message, 'error');
    }
  }
});
```

---

## Phase 6: 재생 네비게이션

### 목표
이전/다음 영상 이동 및 자동 재생

### 수정 파일
- `renderer/scripts/modules/playlist-manager.js`
- `renderer/scripts/app.js`

### 구현

```javascript
// app.js

// 다음 영상
document.getElementById('btnPlaylistNext').addEventListener('click', () => {
  const item = playlistManager.next();
  if (item) {
    loadVideoFromPlaylist(item);
  }
});

// 이전 영상
document.getElementById('btnPlaylistPrev').addEventListener('click', () => {
  const item = playlistManager.prev();
  if (item) {
    loadVideoFromPlaylist(item);
  }
});

// 자동 재생 토글
document.getElementById('playlistAutoPlay').addEventListener('change', (e) => {
  playlistManager.setAutoPlay(e.target.checked);
});

// 영상 종료 시 자동 재생
mpvPlayer.on('end-file', (reason) => {
  if (reason === 'eof' && playlistManager.currentPlaylist?.settings.autoPlay) {
    const nextItem = playlistManager.next();
    if (nextItem) {
      loadVideoFromPlaylist(nextItem);
    }
  }
});

// 재생목록에서 영상 로드
async function loadVideoFromPlaylist(item) {
  // 현재 영상 저장
  if (reviewDataManager.isModified) {
    await reviewDataManager.save();
  }

  // 새 영상 로드
  await loadVideo(item.videoPath, item.bframePath);

  // UI 업데이트
  updatePlaylistCurrentItem();
  updatePlaylistPosition();
}

// 현재 아이템 하이라이트
function updatePlaylistCurrentItem() {
  document.querySelectorAll('.playlist-item').forEach((el, index) => {
    el.classList.toggle('active', index === playlistManager.currentIndex);
  });
}

// 위치 표시 업데이트
function updatePlaylistPosition() {
  const pos = playlistManager.currentIndex + 1;
  const total = playlistManager.currentPlaylist?.items.length || 0;
  document.getElementById('playlistPosition').textContent = `${pos} / ${total}`;
}
```

### 단축키 추가

```javascript
// 키보드 단축키
document.addEventListener('keydown', (e) => {
  // Ctrl+왼쪽: 이전 영상
  if (e.ctrlKey && e.key === 'ArrowLeft' && playlistManager.currentPlaylist) {
    e.preventDefault();
    document.getElementById('btnPlaylistPrev').click();
  }

  // Ctrl+오른쪽: 다음 영상
  if (e.ctrlKey && e.key === 'ArrowRight' && playlistManager.currentPlaylist) {
    e.preventDefault();
    document.getElementById('btnPlaylistNext').click();
  }
});
```

---

## Phase 7: 피드백 완료율 표시

### 목표
각 아이템 및 전체 재생목록의 피드백 완료율 표시

### 수정 파일
- `renderer/scripts/modules/playlist-manager.js`
- `renderer/styles/playlist-panel.css`
- `renderer/scripts/app.js`

### 아이템별 완료율 렌더링

```javascript
// app.js

async function renderPlaylistItems() {
  const container = document.getElementById('playlistItems');
  container.innerHTML = '';

  if (!playlistManager.currentPlaylist) return;

  for (let i = 0; i < playlistManager.currentPlaylist.items.length; i++) {
    const item = playlistManager.currentPlaylist.items[i];
    const progress = await playlistManager.getItemProgress(item.bframePath);

    const el = document.createElement('div');
    el.className = 'playlist-item' + (i === playlistManager.currentIndex ? ' active' : '');
    el.dataset.id = item.id;
    el.dataset.index = i;
    el.draggable = true;

    el.innerHTML = `
      <div class="playlist-item-drag-handle">
        <svg viewBox="0 0 24 24" width="16" height="16" fill="currentColor">
          <circle cx="9" cy="5" r="1.5"/><circle cx="15" cy="5" r="1.5"/>
          <circle cx="9" cy="12" r="1.5"/><circle cx="15" cy="12" r="1.5"/>
          <circle cx="9" cy="19" r="1.5"/><circle cx="15" cy="19" r="1.5"/>
        </svg>
      </div>
      <div class="playlist-item-thumbnail">
        ${item.thumbnailPath
          ? `<img src="file://${item.thumbnailPath}" alt="">`
          : '<div class="thumbnail-placeholder"></div>'
        }
      </div>
      <div class="playlist-item-info">
        <div class="playlist-item-name" title="${item.fileName}">${item.fileName}</div>
        <div class="playlist-item-stats">
          <span class="playlist-item-comments">
            <svg viewBox="0 0 24 24" width="12" height="12" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"/>
            </svg>
            ${progress.total}
          </span>
          <span class="playlist-item-progress ${progress.percent === 100 ? 'completed' : ''}">
            <div class="mini-progress-bar">
              <div class="mini-progress-fill" style="width: ${progress.percent}%"></div>
            </div>
            ${progress.percent}%
          </span>
        </div>
      </div>
      <button class="playlist-item-remove" title="제거">
        <svg viewBox="0 0 24 24" width="14" height="14" fill="none" stroke="currentColor" stroke-width="2">
          <line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/>
        </svg>
      </button>
    `;

    container.appendChild(el);
  }

  // 전체 진행률 업데이트
  await updateTotalProgress();
}

async function updateTotalProgress() {
  const progress = await playlistManager.getTotalProgress();

  document.getElementById('playlistProgressFill').style.width = `${progress.percent}%`;
  document.getElementById('playlistProgressText').textContent =
    `${progress.resolved}/${progress.total} 완료 (${progress.percent}%)`;
}
```

### CSS

```css
/* playlist-panel.css */

.playlist-item-stats {
  display: flex;
  align-items: center;
  gap: 12px;
  font-size: 11px;
  color: var(--text-secondary);
}

.playlist-item-comments {
  display: flex;
  align-items: center;
  gap: 4px;
}

.playlist-item-progress {
  display: flex;
  align-items: center;
  gap: 6px;
}

.playlist-item-progress.completed {
  color: var(--success);
}

.mini-progress-bar {
  width: 40px;
  height: 4px;
  background: var(--bg-tertiary);
  border-radius: 2px;
  overflow: hidden;
}

.mini-progress-fill {
  height: 100%;
  background: var(--accent-primary);
  transition: width var(--transition-normal);
}

.playlist-item-progress.completed .mini-progress-fill {
  background: var(--success);
}

/* 전체 진행률 바 */
.playlist-progress-bar {
  height: 24px;
  background: var(--bg-tertiary);
  border-radius: 4px;
  margin: 8px 12px;
  position: relative;
  overflow: hidden;
}

.playlist-progress-fill {
  height: 100%;
  background: linear-gradient(90deg, var(--accent-primary), var(--accent-secondary));
  transition: width var(--transition-slow);
}

.playlist-progress-text {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 11px;
  font-weight: 500;
  color: var(--text-primary);
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
}
```

---

## Phase 8: 드래그 순서 변경

### 목표
아이템 드래그로 순서 재정렬

### 수정 파일
- `renderer/scripts/app.js`

### 구현

```javascript
// app.js

function initPlaylistDragReorder() {
  const container = document.getElementById('playlistItems');
  let draggedItem = null;
  let draggedIndex = -1;

  container.addEventListener('dragstart', (e) => {
    const item = e.target.closest('.playlist-item');
    if (!item) return;

    draggedItem = item;
    draggedIndex = parseInt(item.dataset.index);

    item.classList.add('dragging');
    e.dataTransfer.effectAllowed = 'move';
    e.dataTransfer.setData('text/plain', item.dataset.id);
  });

  container.addEventListener('dragend', (e) => {
    if (draggedItem) {
      draggedItem.classList.remove('dragging');
      draggedItem = null;
      draggedIndex = -1;
    }

    // 플레이스홀더 제거
    container.querySelectorAll('.drag-placeholder').forEach(el => el.remove());
  });

  container.addEventListener('dragover', (e) => {
    e.preventDefault();

    const afterElement = getDragAfterElement(container, e.clientY);
    const placeholder = container.querySelector('.drag-placeholder') || createDragPlaceholder();

    if (afterElement) {
      container.insertBefore(placeholder, afterElement);
    } else {
      container.appendChild(placeholder);
    }
  });

  container.addEventListener('drop', (e) => {
    e.preventDefault();

    const placeholder = container.querySelector('.drag-placeholder');
    if (!placeholder || draggedIndex === -1) return;

    const items = [...container.querySelectorAll('.playlist-item:not(.dragging)')];
    const toIndex = items.indexOf(placeholder.previousElementSibling) + 1;

    placeholder.remove();

    if (toIndex !== draggedIndex) {
      playlistManager.reorderItem(draggedIndex, toIndex > draggedIndex ? toIndex - 1 : toIndex);
      renderPlaylistItems();
    }
  });

  function getDragAfterElement(container, y) {
    const items = [...container.querySelectorAll('.playlist-item:not(.dragging)')];

    return items.reduce((closest, child) => {
      const box = child.getBoundingClientRect();
      const offset = y - box.top - box.height / 2;

      if (offset < 0 && offset > closest.offset) {
        return { offset, element: child };
      } else {
        return closest;
      }
    }, { offset: Number.NEGATIVE_INFINITY }).element;
  }

  function createDragPlaceholder() {
    const el = document.createElement('div');
    el.className = 'drag-placeholder';
    return el;
  }
}
```

### CSS

```css
.playlist-item.dragging {
  opacity: 0.4;
}

.drag-placeholder {
  height: var(--playlist-item-height);
  background: var(--accent-glow);
  border: 2px dashed var(--accent-primary);
  border-radius: 6px;
  margin: 4px 0;
}

.playlist-item-drag-handle {
  cursor: grab;
  padding: 4px;
  color: var(--text-tertiary);
  transition: color var(--transition-fast);
}

.playlist-item-drag-handle:hover {
  color: var(--text-primary);
}

.playlist-item.dragging .playlist-item-drag-handle {
  cursor: grabbing;
}
```

---

## Phase 9: 링크 공유 기능

### 목표
`baeframe://playlist?file=...` 프로토콜로 재생목록 공유

### 수정 파일
- `main/index.js` - 프로토콜 파싱 수정
- `main/ipc-handlers.js` - 재생목록 링크 생성
- `renderer/scripts/app.js` - 링크 복사 버튼

### 프로토콜 파싱 수정

```javascript
// main/index.js

function parseBaeframeUrl(url) {
  // 기존 영상 링크 파싱...

  // 재생목록 링크 파싱
  if (url.includes('playlist?file=')) {
    const match = url.match(/playlist\?file=(.+)/);
    if (match) {
      const playlistPath = decodeURIComponent(match[1]);
      return { type: 'playlist', path: normalizePath(playlistPath) };
    }
  }

  // 기존 영상 링크
  return { type: 'video', path: ... };
}

// 앱 시작 시 처리
app.on('second-instance', (event, argv) => {
  const url = argv.find(arg => arg.startsWith('baeframe://'));
  if (url) {
    const parsed = parseBaeframeUrl(url);

    if (parsed.type === 'playlist') {
      mainWindow.webContents.send('open-playlist', parsed.path);
    } else if (parsed.type === 'video') {
      mainWindow.webContents.send('open-file', parsed.path);
    }
  }
});
```

### IPC 핸들러

```javascript
// main/ipc-handlers.js

ipcMain.handle('playlist:read', async (event, filePath) => {
  try {
    const content = await fs.promises.readFile(filePath, 'utf-8');
    return JSON.parse(content);
  } catch (error) {
    throw new Error(`재생목록 파일을 읽을 수 없습니다: ${error.message}`);
  }
});

ipcMain.handle('playlist:write', async (event, filePath, data) => {
  await fs.promises.writeFile(filePath, JSON.stringify(data, null, 2), 'utf-8');
  return true;
});

ipcMain.handle('playlist:generate-link', async (event, playlistPath) => {
  const encodedPath = encodeURIComponent(playlistPath);
  return `baeframe://playlist?file=${encodedPath}`;
});
```

### 링크 복사 UI

```javascript
// app.js

document.getElementById('btnPlaylistCopyLink').addEventListener('click', async () => {
  if (!playlistManager.playlistPath) {
    // 저장 안 된 상태: 먼저 저장
    try {
      await playlistManager.save();
      showToast('재생목록이 저장되었습니다.', 'success');
    } catch (error) {
      showToast('재생목록을 먼저 저장해주세요.', 'error');
      return;
    }
  }

  const link = await window.electronAPI.generatePlaylistLink(playlistManager.playlistPath);
  await window.electronAPI.copyToClipboard(link);
  showToast('재생목록 링크가 복사되었습니다!', 'success');
});
```

---

## Phase 10: 플로팅 모드 UI

### 목표
좌측 사이드바 ↔ 플로팅 팝업 전환

### 수정 파일
- `renderer/styles/playlist-panel.css`
- `renderer/scripts/app.js`

### 플로팅 모드 CSS

```css
/* playlist-panel.css */

.playlist-sidebar.floating {
  position: fixed;
  top: 100px;
  left: 100px;
  width: 320px;
  height: 500px;
  border-radius: 12px;
  border: 1px solid var(--border-default);
  box-shadow: var(--shadow-lg);
  z-index: 1000;
  resize: both;
  overflow: auto;
}

.playlist-sidebar.floating .playlist-header {
  cursor: move;
}

/* 토글 버튼 */
.playlist-mode-toggle {
  width: 24px;
  height: 24px;
  padding: 4px;
  border-radius: 4px;
  background: transparent;
  border: none;
  color: var(--text-secondary);
  cursor: pointer;
  transition: all var(--transition-fast);
}

.playlist-mode-toggle:hover {
  background: var(--bg-hover);
  color: var(--text-primary);
}
```

### 플로팅 모드 구현

```javascript
// app.js

let isPlaylistFloating = false;
let playlistDragOffset = { x: 0, y: 0 };

document.getElementById('btnPlaylistSettings').addEventListener('click', () => {
  // 설정 메뉴 표시 (플로팅 모드 토글 포함)
  showPlaylistSettingsMenu();
});

function togglePlaylistFloatingMode() {
  const sidebar = document.getElementById('playlistSidebar');
  isPlaylistFloating = !isPlaylistFloating;

  if (isPlaylistFloating) {
    sidebar.classList.add('floating');
    playlistManager.setFloatingMode(true);
    initPlaylistFloatingDrag();
  } else {
    sidebar.classList.remove('floating');
    sidebar.style.top = '';
    sidebar.style.left = '';
    playlistManager.setFloatingMode(false);
  }
}

function initPlaylistFloatingDrag() {
  const sidebar = document.getElementById('playlistSidebar');
  const header = sidebar.querySelector('.playlist-header');

  header.addEventListener('mousedown', (e) => {
    if (!isPlaylistFloating) return;

    playlistDragOffset.x = e.clientX - sidebar.offsetLeft;
    playlistDragOffset.y = e.clientY - sidebar.offsetTop;

    document.addEventListener('mousemove', onPlaylistDrag);
    document.addEventListener('mouseup', () => {
      document.removeEventListener('mousemove', onPlaylistDrag);
    }, { once: true });
  });
}

function onPlaylistDrag(e) {
  const sidebar = document.getElementById('playlistSidebar');
  sidebar.style.left = `${e.clientX - playlistDragOffset.x}px`;
  sidebar.style.top = `${e.clientY - playlistDragOffset.y}px`;
}
```

---

## Phase 11: 실시간 동기화

### 목표
`.bplaylist.collab` 파일로 협업자 간 실시간 동기화

### 신규 파일
- `renderer/scripts/modules/playlist-collaboration.js`

### 동기화 방식
기존 `.bframe` 협업 방식과 동일:
1. `.bplaylist.collab` 파일에 presence 정보 저장
2. 5초마다 파일 감시
3. 변경 감지 시 머지

### 스키마

```javascript
// .bplaylist.collab
{
  "presence": {
    "session_abc": {
      "userName": "윤성원",
      "userColor": "#4a90ff",
      "timestamp": "2024-01-24T12:00:00Z"
    }
  }
}
```

### 구현 (기존 CollaborationManager 참조)

```javascript
// playlist-collaboration.js

export class PlaylistCollaborationManager {
  constructor(playlistManager) {
    this.playlistManager = playlistManager;
    this.collabPath = null;
    this.syncInterval = null;
    this.lastModified = null;
  }

  async start(playlistPath) {
    this.collabPath = playlistPath + '.collab';
    await this.updatePresence();
    this.syncInterval = setInterval(() => this.sync(), 5000);
  }

  async sync() {
    // 1. 파일 변경 감지
    const stats = await window.electronAPI.getFileStats(this.playlistManager.playlistPath);

    if (stats.mtime > this.lastModified) {
      // 2. 원격 데이터 로드 및 머지
      const remoteData = await window.electronAPI.readPlaylist(this.playlistManager.playlistPath);
      await this.mergePlaylist(remoteData);
      this.lastModified = stats.mtime;
    }
  }

  async mergePlaylist(remoteData) {
    const local = this.playlistManager.currentPlaylist;

    // modifiedAt 비교로 최신 결정
    if (new Date(remoteData.modifiedAt) > new Date(local.modifiedAt)) {
      // 원격이 최신: 원격 데이터 적용
      this.playlistManager.currentPlaylist = remoteData;
      this.playlistManager.onPlaylistLoaded?.(remoteData);
    }
  }

  stop() {
    if (this.syncInterval) {
      clearInterval(this.syncInterval);
      this.syncInterval = null;
    }
  }
}
```

---

## Phase 12: 미니 인디케이터

### 목표
헤더에 재생목록 진행 상황 미니 표시

### 수정 파일
- `renderer/index.html`
- `renderer/styles/main.css`
- `renderer/scripts/app.js`

### HTML

```html
<!-- index.html - header-left에 추가 -->
<div class="playlist-mini-indicator" id="playlistMiniIndicator" style="display: none;">
  <button class="playlist-mini-btn" id="btnPlaylistMiniToggle" title="재생목록 열기/닫기">
    <svg viewBox="0 0 24 24" width="16" height="16" fill="none" stroke="currentColor" stroke-width="2">
      <line x1="8" y1="6" x2="21" y2="6"/>
      <line x1="8" y1="12" x2="21" y2="12"/>
      <line x1="8" y1="18" x2="21" y2="18"/>
      <line x1="3" y1="6" x2="3.01" y2="6"/>
      <line x1="3" y1="12" x2="3.01" y2="12"/>
      <line x1="3" y1="18" x2="3.01" y2="18"/>
    </svg>
  </button>
  <span class="playlist-mini-position" id="playlistMiniPosition">1/10</span>
  <div class="playlist-mini-progress" id="playlistMiniProgress">
    <div class="playlist-mini-progress-fill"></div>
  </div>
</div>
```

### CSS

```css
/* main.css */

.playlist-mini-indicator {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 4px 10px;
  background: var(--bg-tertiary);
  border-radius: 6px;
  border: 1px solid var(--border-subtle);
  margin-left: 12px;
}

.playlist-mini-btn {
  width: 24px;
  height: 24px;
  padding: 4px;
  background: transparent;
  border: none;
  border-radius: 4px;
  color: var(--accent-primary);
  cursor: pointer;
  transition: all var(--transition-fast);
}

.playlist-mini-btn:hover {
  background: var(--accent-glow);
}

.playlist-mini-position {
  font-size: 12px;
  font-weight: 500;
  color: var(--text-primary);
  min-width: 32px;
  text-align: center;
}

.playlist-mini-progress {
  width: 60px;
  height: 4px;
  background: var(--bg-elevated);
  border-radius: 2px;
  overflow: hidden;
}

.playlist-mini-progress-fill {
  height: 100%;
  background: var(--accent-primary);
  transition: width var(--transition-normal);
}
```

### JavaScript

```javascript
// app.js

function updatePlaylistMiniIndicator() {
  const indicator = document.getElementById('playlistMiniIndicator');

  if (!playlistManager.currentPlaylist) {
    indicator.style.display = 'none';
    return;
  }

  indicator.style.display = 'flex';

  const pos = playlistManager.currentIndex + 1;
  const total = playlistManager.currentPlaylist.items.length;
  document.getElementById('playlistMiniPosition').textContent = `${pos}/${total}`;

  // 진행률 업데이트 (비동기)
  playlistManager.getTotalProgress().then(progress => {
    document.querySelector('.playlist-mini-progress-fill').style.width = `${progress.percent}%`;
  });
}

// 사이드바 토글
document.getElementById('btnPlaylistMiniToggle').addEventListener('click', () => {
  const sidebar = document.getElementById('playlistSidebar');
  sidebar.classList.toggle('hidden');
});
```

---

## 리스크 및 우려 사항

| 리스크 | 심각도 | 완화 방안 |
|--------|--------|----------|
| 레이아웃 깨짐 | 높음 | 기존 viewer-section 영향 최소화, 테스트 철저 |
| ffmpeg 없는 환경 | 중간 | 플레이스홀더 이미지 사용, 에러 핸들링 |
| 대용량 재생목록 | 중간 | 50개 제한, 가상화 스크롤 고려 |
| 동기화 충돌 | 중간 | modifiedAt 비교, 머지 로직 |
| 파일 경로 변경 | 중간 | 파일 존재 여부 체크, 누락 알림 |
| 썸네일 캐시 용량 | 낮음 | 주기적 정리, 오래된 캐시 삭제 |

---

## 테스트 방법

### Phase별 테스트 체크리스트

#### Phase 1-2 (스키마 & 썸네일)
- [ ] `.bplaylist` 파일 생성/저장/로드
- [ ] 스키마 검증 동작
- [ ] 썸네일 자동 생성
- [ ] 썸네일 캐시 경로 확인

#### Phase 3-5 (UI & 파일 관리)
- [ ] 좌측 사이드바 표시/숨김
- [ ] 드래그 앤 드롭으로 파일 추가
- [ ] 파일 선택 다이얼로그로 추가
- [ ] 아이템 제거
- [ ] 최대 50개 제한

#### Phase 6-8 (네비게이션 & 정렬)
- [ ] 이전/다음 영상 이동
- [ ] 자동 재생 토글
- [ ] 단축키 (Ctrl+좌/우)
- [ ] 드래그로 순서 변경

#### Phase 9 (링크 공유)
- [ ] 재생목록 링크 생성
- [ ] 링크 클릭 시 앱에서 열기
- [ ] 저장 안 된 상태에서 링크 복사 시 자동 저장

#### Phase 10-12 (플로팅 & 동기화)
- [ ] 플로팅 모드 전환
- [ ] 플로팅 팝업 드래그 이동
- [ ] 협업자 간 동기화
- [ ] 미니 인디케이터 표시

---

## 구현 순서 권장

1. **Phase 1** - 스키마 정의 (기초)
2. **Phase 2** - 썸네일 시스템 (기초)
3. **Phase 3** - 기본 UI (시각적 확인)
4. **Phase 4** - 매니저 모듈 (핵심 로직)
5. **Phase 5** - 파일 추가/제거 (핵심 기능)
6. **Phase 6** - 재생 네비게이션 (핵심 기능)
7. **Phase 9** - 링크 공유 (핵심 기능)
8. **Phase 7** - 피드백 완료율 (UX 개선)
9. **Phase 8** - 드래그 순서 변경 (UX 개선)
10. **Phase 12** - 미니 인디케이터 (UX 개선)
11. **Phase 10** - 플로팅 모드 (부가 기능)
12. **Phase 11** - 실시간 동기화 (부가 기능)

---

## 예상 작업량

| Phase | 예상 복잡도 |
|-------|------------|
| 1 | 낮음 |
| 2 | 중간 |
| 3 | 중간 |
| 4 | 높음 |
| 5 | 중간 |
| 6 | 중간 |
| 7 | 낮음 |
| 8 | 중간 |
| 9 | 중간 |
| 10 | 중간 |
| 11 | 높음 |
| 12 | 낮음 |

---

## 참고 자료

- 기존 협업 동기화: `DEVLOG/실시간-협업-동기화-구현-계획.md`
- .bframe 스키마: `shared/schema.js`
- 링크 공유 로직: `main/index.js:66-139`, `main/ipc-handlers.js:513-556`
- UI 패턴: `renderer/index.html`, `renderer/styles/main.css`
