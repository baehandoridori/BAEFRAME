# 로그인 시스템 구현 계획

## 요약

| 항목 | 수정 파일 | 이유 | 우선순위 | 상태 |
|------|----------|------|---------|------|
| Phase 1 | main/ipc-handlers.js, preload/preload.js | 인증 파일 읽기/쓰기 IPC | 높음 | ✅ 완료 |
| Phase 2 | renderer/scripts/modules/auth-manager.js (신규) | 인증 로직 모듈 | 높음 | ✅ 완료 |
| Phase 3 | renderer/scripts/modules/user-settings.js | 로그인 연동 | 높음 | ✅ 완료 |
| Phase 4 | renderer/index.html, renderer/styles/ | 로그인 UI | 높음 | ✅ 완료 |
| Phase 5 | renderer/scripts/modules/comment-manager.js | 코멘트/답글 권한 체크 | 높음 | ✅ 완료 |
| Phase 6 | 전체 | 테스트 (3개 환경) | 중간 | ⬜ 대기 |

---

## 배경 및 목적

### 왜 필요한가?
현재 BAEFRAME은 사용자 이름만 설정하면 누구나 해당 이름으로 활동할 수 있음. 이로 인해:
- 다른 사람 이름으로 코멘트 작성 가능
- 다른 사람의 코멘트 수정/삭제 가능
- 책임 소재가 불분명

### 해결하려는 문제
- 특정 이름(팀원)에 비밀번호를 설정하여 본인만 사용 가능하게
- 본인 코멘트/답글만 수정/삭제 가능하도록 제한
- 비밀번호 없는 이름(외부 리뷰어 등)은 자유롭게 사용 가능

### 핵심 요구사항
1. **비밀번호 보호 사용자**: 특정 이름들에만 비밀번호 설정
2. **비밀번호 없는 사용자**: 자유롭게 사용 (본인 코멘트만 수정/삭제)
3. **초기 비밀번호**: 모두 "1234" → 각자 개인 비밀번호로 변경
4. **로그인 유지**: 앱 재시작해도 로그인 상태 유지 (재입력 불필요)
5. **비밀번호 변경**: 이전 비밀번호 확인 → 새 비밀번호 설정
6. **로그아웃**: "이름 변경" = 로그아웃 + 새 로그인으로 처리
7. **답글 권한**: 답글도 본인만 수정/삭제 가능
8. **resolved 상태**: 아무나 변경 가능 (리뷰어가 "확인했어요" 표시용)
9. **사용자 삭제**: 잘못 등록한 사용자 삭제 기능 필요
10. **사용자 테마**: 기본 테마(노랑), 특정 사용자는 개인 테마 설정 가능

### 명시적으로 불필요한 것
- 복잡한 보안 (해킹 방지 수준의 암호화 불필요)
- 웹 뷰어 로그인 (데스크탑 앱만 해당)
- 세션 잠금/타임아웃
- 비밀번호 찾기/복구 기능

---

## 개발/테스트/배포 환경 (중요!)

### 세 가지 환경

| 환경 | 경로 | 실행 방법 | 인증 파일 위치 |
|------|------|----------|---------------|
| **개발** | `C:\BAEframe\BAEFRAME\` | `run-baeframe.bat` | 프로젝트 루트 |
| **개발 빌드** | `C:\BAEframe\BAEFRAME\dist\win-unpacked\` | `BFRAME_alpha_v2.exe` | exe 옆 |
| **배포** | `G:\공유 드라이브\JBBJ 자료실\한솔이의 두근두근 실험실\BAEFRAME\테스트버전 빌드\` | `BFRAME_alpha_v2.exe` | exe 옆 (팀 공유) |

### 환경별 인증 파일 경로 결정 로직

```javascript
const getAuthFilePath = () => {
  if (app.isPackaged) {
    // 프로덕션 (빌드된 exe): exe 파일 옆
    return path.join(path.dirname(process.execPath), 'baeframe-auth.dat');
  } else {
    // 개발 모드 (npm start/dev): 프로젝트 루트
    return path.join(app.getAppPath(), 'baeframe-auth.dat');
  }
};
```

### 환경별 동작

1. **개발 환경**
   - `C:\BAEframe\BAEFRAME\baeframe-auth.dat` 생성
   - 개발자 로컬에서만 사용 (팀과 분리)

2. **개발 빌드 환경**
   - `C:\BAEframe\BAEFRAME\dist\win-unpacked\baeframe-auth.dat` 생성
   - 빌드 테스트용 (팀과 분리)

3. **배포 환경**
   - `G:\...\테스트버전 빌드\baeframe-auth.dat` 생성
   - **팀 전체 공유** (Google Drive 동기화)

### 인증 파일 접근 불가 시

exe를 다른 위치에 복사해서 실행하거나, 인증 파일이 없는 경우:
- **경고 토스트**: "인증 파일을 찾을 수 없습니다. 비보호 모드로 실행됩니다."
- **비보호 모드**: 로그인 없이 자유 사용 (기존 동작과 동일)
- 코멘트 권한 체크는 여전히 적용 (본인 코멘트만 수정/삭제)

---

## 팀 배포 환경 구조

```
G:\공유 드라이브\JBBJ 자료실\한솔이의 두근두근 실험실\BAEFRAME\
├── 테스트버전 빌드\
│   ├── BFRAME_alpha_v2.exe     ← 모든 팀원이 이걸 실행
│   ├── baeframe-auth.dat       ← 인증 파일 (앱이 자동 생성, 팀 공유)
│   └── resources\              ← Electron 리소스
├── 프로젝트A\
│   └── video.bframe
└── 프로젝트B\
    └── video.bframe
```

### 핵심 인사이트
- **모든 팀원이 같은 exe 파일 사용** → exe 옆에 인증 파일 두면 자동 공유
- **Google Drive 동기화** → 한 명이 변경하면 전 팀원에게 적용
- **서버 불필요** → 파일 기반으로 중앙 DB처럼 동작
- **개발/배포 분리** → 개발 테스트가 팀 인증 데이터에 영향 안 줌

---

## 데이터 구조

### 인증 파일 (baeframe-auth.dat)

**위치**: exe 파일과 같은 폴더 (환경별로 다름 - 위 참고)
**형식**: JSON (Base64 인코딩으로 눈에 안 띄게)

```javascript
// 실제 저장 형태: Base64 인코딩된 문자열
// eyJ1c2VycyI6W3sibmFtZSI6...

// 디코딩된 내용:
{
  "version": 1,
  "users": [
    {
      "name": "한솔",
      "passwordHash": "sha256해시값",  // 평문 대신 해시 저장
      "theme": "red",                  // 개인 테마 (선택사항)
      "createdAt": "2024-01-10T10:00:00.000Z",
      "updatedAt": "2024-01-15T14:30:00.000Z"
    },
    {
      "name": "성원",
      "passwordHash": "sha256해시값",
      "theme": "blue",
      "createdAt": "2024-01-10T10:00:00.000Z",
      "updatedAt": "2024-01-10T10:00:00.000Z"
    },
    {
      "name": "민수",
      "passwordHash": "sha256해시값",
      "theme": null,                   // null이면 기본 테마(노랑) 사용
      "createdAt": "2024-01-12T10:00:00.000Z",
      "updatedAt": "2024-01-12T10:00:00.000Z"
    }
  ]
}
```

**테마 값**:
- `null` 또는 미지정: 기본 테마 (노랑, #ffd000)
- `"red"`: 빨강 (#ff5555)
- `"blue"`: 파랑 (#4a9eff)
- `"pink"`: 핑크 (#ffaaaa)
- `"green"`: 초록 (#2ed573)
- 기존 user-settings.js의 테마 시스템과 연동

**왜 Base64 + SHA256?**
- Base64: 파일 열어도 내용이 바로 안 보임 (팀원들이 실수로 건드리지 않게)
- SHA256: 비밀번호 평문 저장 방지 (기본적인 보호)
- 복잡한 암호화는 불필요 (요구사항에 따라)

### 로컬 세션 파일 (user-settings.json 확장)

**위치**: `%APPDATA%\baeframe\settings\user-settings.json` (기존 파일)

```javascript
{
  "userName": "한솔",
  "userSource": "manual",
  // ... 기존 필드들 ...

  // 추가되는 필드
  "isAuthenticated": true,      // 로그인 상태
  "authToken": "랜덤토큰값",     // 세션 토큰 (로그인 유지용)
  "lastAuthAt": "2024-01-15T14:30:00.000Z"
}
```

**왜 authToken?**
- 비밀번호를 로컬에 저장하지 않기 위함
- 앱 재시작 시 토큰으로 자동 로그인
- 비밀번호 변경 시 토큰 갱신 → 다른 PC에서 재로그인 필요

---

## Phase 1: 인증 파일 IPC 핸들러

### 목표
메인 프로세스에서 인증 파일 읽기/쓰기 기능 구현

### 수정 파일
- `main/ipc-handlers.js`
- `preload/preload.js`

### 구현 내용

#### main/ipc-handlers.js
```javascript
// 인증 파일 경로 (exe와 같은 폴더)
const getAuthFilePath = () => {
  // 개발 모드: 프로젝트 루트
  // 프로덕션: exe 파일 위치
  const basePath = app.isPackaged
    ? path.dirname(process.execPath)
    : app.getAppPath();
  return path.join(basePath, 'baeframe-auth.dat');
};

// 인증 데이터 로드
ipcMain.handle('auth:load', async () => {
  const filePath = getAuthFilePath();
  if (!fs.existsSync(filePath)) {
    return { success: true, data: null };
  }
  const encoded = await fs.promises.readFile(filePath, 'utf-8');
  const decoded = Buffer.from(encoded, 'base64').toString('utf-8');
  return { success: true, data: JSON.parse(decoded) };
});

// 인증 데이터 저장
ipcMain.handle('auth:save', async (event, data) => {
  const filePath = getAuthFilePath();
  const json = JSON.stringify(data, null, 2);
  const encoded = Buffer.from(json).toString('base64');
  await fs.promises.writeFile(filePath, encoded, 'utf-8');
  return { success: true };
});
```

#### preload/preload.js
```javascript
// contextBridge.exposeInMainWorld('electronAPI', { ... })에 추가
loadAuthData: () => ipcRenderer.invoke('auth:load'),
saveAuthData: (data) => ipcRenderer.invoke('auth:save', data),
```

### 예상 리스크
- Google Drive 동기화 충돌 (동시 수정 시)
  - 완화: 저장 전 최신 데이터 로드 후 머지

---

## Phase 2: 인증 매니저 모듈

### 목표
인증 로직을 담당하는 독립 모듈 생성

### 수정 파일
- `renderer/scripts/modules/auth-manager.js` (신규)

### 구현 내용

```javascript
// auth-manager.js
class AuthManager {
  constructor() {
    this.authData = null;       // 전체 인증 데이터
    this.currentUser = null;    // 현재 로그인한 사용자
    this.isAuthenticated = false;
  }

  // 초기화 (앱 시작 시)
  async init() {
    await this._loadAuthData();
    await this._restoreSession();
  }

  // 사용자 등록 (새 팀원 추가)
  async registerUser(name, theme = null) {
    // 중복 체크
    if (this._findUser(name)) {
      throw new Error('이미 등록된 사용자입니다');
    }

    const initialPassword = '1234';
    const hash = await this._hashPassword(initialPassword);

    this.authData.users.push({
      name,
      passwordHash: hash,
      theme,  // null이면 기본 테마(노랑) 사용
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    });

    await this._saveAuthData();
  }

  // 사용자 삭제
  async deleteUser(name) {
    const index = this.authData.users.findIndex(u => u.name === name);
    if (index === -1) {
      throw new Error('등록되지 않은 사용자입니다');
    }

    this.authData.users.splice(index, 1);
    await this._saveAuthData();
  }

  // 사용자 테마 변경
  async changeTheme(theme) {
    if (!this.currentUser?.name) {
      throw new Error('로그인이 필요합니다');
    }

    const user = this._findUser(this.currentUser.name);
    if (!user) {
      // 비보호 사용자는 테마 변경 불가 (로컬에만 저장)
      return false;
    }

    user.theme = theme;
    user.updatedAt = new Date().toISOString();
    await this._saveAuthData();
    return true;
  }

  // 등록된 사용자 목록 반환
  getRegisteredUsers() {
    return this.authData?.users?.map(u => ({
      name: u.name,
      theme: u.theme,
      createdAt: u.createdAt
    })) || [];
  }

  // 로그인
  async login(name, password) {
    const user = this._findUser(name);

    // 비밀번호 보호 사용자
    if (user) {
      const hash = await this._hashPassword(password);
      if (hash !== user.passwordHash) {
        throw new Error('비밀번호가 일치하지 않습니다');
      }
      this.currentUser = user;
      this.isAuthenticated = true;
      await this._saveSession();
      return { protected: true };
    }

    // 비밀번호 없는 사용자 (자유 사용)
    this.currentUser = { name, protected: false };
    this.isAuthenticated = true;
    await this._saveSession();
    return { protected: false };
  }

  // 비밀번호 변경
  async changePassword(oldPassword, newPassword) {
    if (!this.currentUser?.name) {
      throw new Error('로그인이 필요합니다');
    }

    const user = this._findUser(this.currentUser.name);
    if (!user) {
      throw new Error('등록된 사용자가 아닙니다');
    }

    // 이전 비밀번호 확인
    const oldHash = await this._hashPassword(oldPassword);
    if (oldHash !== user.passwordHash) {
      throw new Error('현재 비밀번호가 일치하지 않습니다');
    }

    // 새 비밀번호 설정
    user.passwordHash = await this._hashPassword(newPassword);
    user.updatedAt = new Date().toISOString();

    // 토큰 갱신 (다른 PC에서 재로그인 필요)
    await this._saveAuthData();
    await this._saveSession();
  }

  // 현재 사용자가 해당 코멘트를 수정/삭제할 수 있는지
  canEditComment(comment) {
    if (!this.isAuthenticated) return false;
    return comment.author === this.currentUser.name;
  }

  // 사용자가 보호된 사용자인지 확인
  isProtectedUser(name) {
    return !!this._findUser(name);
  }

  // --- Private ---

  async _hashPassword(password) {
    // Web Crypto API 사용
    const encoder = new TextEncoder();
    const data = encoder.encode(password + 'baeframe_salt');
    const hashBuffer = await crypto.subtle.digest('SHA-256', data);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
  }

  _findUser(name) {
    return this.authData?.users?.find(u => u.name === name);
  }

  async _loadAuthData() {
    const result = await window.electronAPI.loadAuthData();
    this.authData = result.data || { version: 1, users: [] };
  }

  async _saveAuthData() {
    await window.electronAPI.saveAuthData(this.authData);
  }

  async _saveSession() {
    // user-settings.js와 연동하여 세션 저장
  }

  async _restoreSession() {
    // 앱 시작 시 저장된 세션으로 자동 로그인
  }
}

export const authManager = new AuthManager();
```

### 예상 리스크
- 세션 토큰 관리 복잡성
  - 완화: 간단한 UUID 토큰 사용, 복잡한 JWT 불필요

---

## Phase 3: user-settings.js 로그인 연동

### 목표
기존 사용자 설정 시스템과 인증 시스템 통합

### 수정 파일
- `renderer/scripts/modules/user-settings.js`

### 구현 내용

```javascript
// setUserName 수정
async setUserName(name) {
  // 보호된 사용자인지 확인
  if (authManager.isProtectedUser(name)) {
    // 비밀번호 입력 필요 → 이벤트 발생
    this._emit('passwordRequired', { name });
    return false;
  }

  // 비밀번호 없는 사용자 → 바로 설정
  await authManager.login(name, null);
  this.settings.userName = name;
  this.settings.isAuthenticated = true;
  this._save();
  return true;
}

// 로그인 완료 후 호출
async onLoginSuccess(name) {
  this.settings.userName = name;
  this.settings.isAuthenticated = true;
  this._save();
}
```

### 예상 리스크
- 기존 플로우와 충돌
  - 완화: 기존 setUserName 호출부 모두 확인 후 수정

---

## Phase 4: 로그인 UI

### 목표
로그인/비밀번호 변경/사용자 등록 UI 구현

### 수정 파일
- `renderer/index.html` (모달 추가)
- `renderer/styles/main.css` (스타일)
- `renderer/scripts/app.js` (이벤트 핸들링)

### UI 요소

#### 1. 로그인 모달 (비밀번호 보호 사용자 선택 시)
```
┌─────────────────────────────────────┐
│         🔒 로그인                    │
├─────────────────────────────────────┤
│  사용자: 한솔                        │
│                                     │
│  비밀번호: [________]               │
│                                     │
│  [로그인]              [취소]        │
└─────────────────────────────────────┘
```

#### 2. 비밀번호 변경 (설정 메뉴에 추가)
```
┌─────────────────────────────────────┐
│      🔐 비밀번호 변경                │
├─────────────────────────────────────┤
│  현재 비밀번호: [________]           │
│  새 비밀번호:   [________]           │
│  비밀번호 확인: [________]           │
│                                     │
│  [변경]                [취소]        │
└─────────────────────────────────────┘
```

#### 3. 사용자 관리 (설정 메뉴에 추가)
```
┌─────────────────────────────────────┐
│      👥 사용자 관리                  │
├─────────────────────────────────────┤
│  등록된 사용자:                      │
│  • 한솔 🔴 (빨강)           [삭제]   │
│  • 성원 🔵 (파랑)           [삭제]   │
│  • 민수 🟡 (기본)           [삭제]   │
│                                     │
│  [+ 새 사용자 등록]                  │
│                                     │
│  ※ 초기 비밀번호: 1234              │
└─────────────────────────────────────┘
```

#### 4. 새 사용자 등록 모달
```
┌─────────────────────────────────────┐
│      ➕ 새 사용자 등록               │
├─────────────────────────────────────┤
│  이름: [________________]           │
│                                     │
│  테마: [기본(노랑) ▼]               │
│        ┌─────────────┐              │
│        │ 기본 (노랑) │              │
│        │ 빨강        │              │
│        │ 파랑        │              │
│        │ 핑크        │              │
│        │ 초록        │              │
│        └─────────────┘              │
│                                     │
│  [등록]                [취소]        │
│                                     │
│  ※ 초기 비밀번호: 1234              │
└─────────────────────────────────────┘
```

#### 5. 테마 변경 (보호 사용자용, 설정 메뉴에 추가)
```
┌─────────────────────────────────────┐
│      🎨 테마 변경                    │
├─────────────────────────────────────┤
│  현재 테마: 빨강                     │
│                                     │
│  [🟡 기본] [🔴 빨강] [🔵 파랑]      │
│  [🩷 핑크] [🟢 초록]                │
│                                     │
│  [저장]                [취소]        │
└─────────────────────────────────────┘
```

### 설정 드롭다운 메뉴 변경

기존 메뉴에 항목 추가:
```
댓글 설정
├── 썸네일 표시 [토글]
├── 썸네일 크기 [슬라이더]
├── 알림 표시 [토글]
├── ─────────────────
├── 이름 변경        ← 기존 (로그아웃 + 새 로그인)
├── 비밀번호 변경    ← 추가 (보호 사용자만 표시)
├── 테마 변경        ← 추가 (보호 사용자만 표시)
├── ─────────────────
├── 사용자 관리      ← 추가
├── 단축키 설정
└── 캐시 설정
```

### 예상 리스크
- 기존 이름 설정 모달과의 통합
  - 완화: 기존 모달 흐름 유지, 비밀번호 입력만 추가

---

## Phase 5: 코멘트/답글 권한 체크

### 목표
본인 코멘트/답글만 수정/삭제 가능하도록 제한
(resolved 상태는 아무나 변경 가능)

### 수정 파일
- `renderer/scripts/modules/comment-manager.js`
- 관련 UI 파일들

### 권한 규칙

| 동작 | 권한 | 이유 |
|------|------|------|
| 코멘트 텍스트 수정 | 본인만 | 본인 코멘트 보호 |
| 코멘트 삭제 | 본인만 | 본인 코멘트 보호 |
| 코멘트 위치/시간 수정 | 본인만 | 본인 코멘트 보호 |
| **resolved 상태 변경** | **아무나** | 리뷰어가 "확인했어요" 표시용 |
| 답글 수정 | 본인만 | 본인 답글 보호 |
| 답글 삭제 | 본인만 | 본인 답글 보호 |

### 구현 내용

#### comment-manager.js
```javascript
// 마커 수정
updateMarker(markerId, updates) {
  const marker = this.getMarker(markerId);

  // resolved 변경은 누구나 가능
  const isOnlyResolved = Object.keys(updates).length === 1 && 'resolved' in updates;

  if (!isOnlyResolved && !authManager.canEditComment(marker)) {
    console.warn('권한 없음: 본인 코멘트만 수정할 수 있습니다');
    this._emit('permissionDenied', { action: 'update', marker });
    return false;
  }

  // 기존 로직...
}

// 마커 삭제
deleteMarker(markerId) {
  const marker = this.getMarker(markerId);

  // 권한 체크
  if (!authManager.canEditComment(marker)) {
    console.warn('권한 없음: 본인 코멘트만 삭제할 수 있습니다');
    this._emit('permissionDenied', { action: 'delete', marker });
    return false;
  }

  // 기존 로직...
}

// 답글 수정 (추가)
updateReply(markerId, replyId, updates) {
  const marker = this.getMarker(markerId);
  const reply = marker.replies?.find(r => r.id === replyId);

  if (!reply) return false;

  // 권한 체크
  if (!authManager.canEditComment(reply)) {
    console.warn('권한 없음: 본인 답글만 수정할 수 있습니다');
    this._emit('permissionDenied', { action: 'updateReply', reply });
    return false;
  }

  // 기존 로직...
}

// 답글 삭제 (추가)
deleteReply(markerId, replyId) {
  const marker = this.getMarker(markerId);
  const reply = marker.replies?.find(r => r.id === replyId);

  if (!reply) return false;

  // 권한 체크
  if (!authManager.canEditComment(reply)) {
    console.warn('권한 없음: 본인 답글만 삭제할 수 있습니다');
    this._emit('permissionDenied', { action: 'deleteReply', reply });
    return false;
  }

  // 기존 로직...
}
```

#### UI 처리
- 다른 사람 코멘트: 수정/삭제 버튼 비활성화 또는 숨김
- 다른 사람 답글: 수정/삭제 버튼 비활성화 또는 숨김
- **resolved 체크박스**: 항상 활성화 (누구나 체크 가능)
- 권한 없음 시: 토스트 메시지 표시 "본인 코멘트만 수정할 수 있습니다"

### 예상 리스크
- 기존 코멘트의 author와 로그인 이름 불일치 (공백, 대소문자 등)
  - 완화: 이름 비교 시 trim() 처리

---

## Phase 6: 테스트 및 엣지케이스

### 환경별 테스트 (중요!)

**각 환경에서 아래 시나리오를 모두 테스트해야 함:**

| 환경 | 테스트 방법 | 확인 사항 |
|------|------------|----------|
| **개발** | `npm run dev` 실행 | 프로젝트 루트에 `baeframe-auth.dat` 생성 확인 |
| **개발 빌드** | `npm run build` 후 `dist/win-unpacked/BFRAME_alpha_v2.exe` 실행 | exe 옆에 `baeframe-auth.dat` 생성 확인 |
| **배포** | G드라이브의 exe 실행 | exe 옆에 `baeframe-auth.dat` 생성 확인, 다른 PC에서 공유 확인 |

### 기능 테스트 시나리오

1. **신규 사용자 등록**
   - 사용자 관리에서 새 사용자 등록 (이름, 테마 선택)
   - 초기 비밀번호 "1234"로 로그인 확인
   - 중복 이름 등록 시 에러 메시지 확인

2. **사용자 삭제**
   - 등록된 사용자 삭제
   - 삭제된 사용자로 로그인 시 비보호 사용자로 처리되는지 확인

3. **비밀번호 변경**
   - 이전 비밀번호 틀리면 실패
   - 새 비밀번호로 로그인 성공

4. **테마 변경**
   - 보호 사용자: 테마 변경 후 인증 파일에 저장 확인
   - 비보호 사용자: 테마 변경 버튼 숨김 확인

5. **다른 PC에서 로그인** (배포 환경에서만)
   - A PC에서 비밀번호 변경
   - Drive 동기화 대기 (몇 초)
   - B PC에서 새 비밀번호로 로그인 필요

6. **로그아웃 (이름 변경)**
   - "이름 변경" 클릭 시 현재 세션 종료
   - 새 이름 입력 (보호 사용자면 비밀번호 요구)

7. **코멘트 권한**
   - 본인 코멘트: 수정/삭제 가능
   - 타인 코멘트: 수정/삭제 버튼 비활성화
   - **resolved 체크**: 아무 코멘트나 체크/해제 가능

8. **답글 권한**
   - 본인 답글: 수정/삭제 가능
   - 타인 답글: 수정/삭제 버튼 비활성화

9. **비보호 사용자**
   - 등록 안 된 이름으로 자유롭게 로그인
   - 본인 코멘트만 수정/삭제 가능
   - 비밀번호 변경/테마 변경 메뉴 숨김

10. **기존 코멘트 호환성**
    - 로그인 시스템 도입 전 "한솔"로 작성한 코멘트
    - 새 시스템에서 "한솔"로 로그인 후 수정 가능

11. **인증 파일 없음**
    - exe를 다른 폴더에 복사해서 실행
    - 경고 토스트 표시 확인
    - 비보호 모드로 정상 동작 확인

### 엣지케이스

- Google Drive 동기화 지연 (변경 즉시 반영 안 될 수 있음)
  - 대응: "나중에 저장한 사람이 이김" 방식으로 단순 처리
- 인증 파일 손상/삭제 시: 새 파일 생성 (모든 사용자 재등록 필요)
- 오프라인 상태에서 로그인: 마지막 로드된 인증 데이터 사용

---

## 리스크 및 우려 사항

| 리스크 | 심각도 | 완화 방안 |
|--------|--------|----------|
| Drive 동기화 지연 | 중간 | "나중에 저장한 사람이 이김" 방식으로 단순 처리, 사용자에게 동기화 대기 안내 |
| 인증 파일 삭제 | 낮음 | 파일 없으면 새로 생성 (모든 사용자 재등록 필요) |
| 비밀번호 분실 | 낮음 | 관리자가 직접 파일 편집 (Base64 디코딩 후 해당 사용자 삭제 → 재등록) |
| 이름 불일치 | 낮음 | trim() 처리, 대소문자 구분 |
| exe 복사 실행 | 낮음 | 경고 표시 + 비보호 모드로 동작 |
| 개발/배포 혼동 | 낮음 | 각 환경별 별도 인증 파일 사용 (자연스럽게 분리됨) |

---

## 구현 순서 요약

```
1. Phase 1: IPC 핸들러 (인증 파일 읽기/쓰기)
   ↓
2. Phase 2: AuthManager 모듈 (인증 로직)
   ↓
3. Phase 3: user-settings.js 연동
   ↓
4. Phase 4: UI (로그인/비밀번호 변경/사용자 관리)
   ↓
5. Phase 5: 코멘트 권한 체크
   ↓
6. Phase 6: 테스트
```

---

## 참고: 현재 관련 코드 위치

### 핵심 파일

| 파일 | 역할 | 관련 줄 번호 |
|------|------|-------------|
| `main/ipc-handlers.js` | IPC 핸들러 (settings:load/save 참고) | 585-632 |
| `preload/preload.js` | IPC 브릿지 | - |
| `renderer/scripts/modules/user-settings.js` | 사용자 설정/테마 관리 | 전체 |
| `renderer/scripts/modules/comment-manager.js` | 코멘트 CRUD | 전체 |
| `renderer/scripts/app.js` | 메인 앱 로직 | - |
| `renderer/index.html` | UI (모달 등) | - |

### UI 관련 상세 위치

| 항목 | 파일 | 줄 번호 |
|------|------|---------|
| 사용자 설정 모달 HTML | `renderer/index.html` | 1029-1047 |
| 사용자 설정 모달 JS | `renderer/scripts/app.js` | 5066-5151 |
| 설정 드롭다운 HTML | `renderer/index.html` | 747-789 |
| 설정 드롭다운 JS | `renderer/scripts/app.js` | 1160-1195 |
| 모달 스타일 | `renderer/styles/main.css` | 4267-4436 |
| 사용자 테마 매핑 | `renderer/scripts/modules/user-settings.js` | 60-128 |

### 테마 색상 정의 (user-settings.js)

```javascript
// 현재 하드코딩된 사용자별 테마
한솔, 배한솔, 한솔쿤 → red (#ff5555)
윤성원, 성원, SW, sw → blue (#4a9eff)
허혜원, 혜원, 모몽가 → pink (#ffaaaa)
기본 → yellow (#ffd000)
```

**참고**: 로그인 시스템 도입 후, 이 하드코딩된 테마 대신 인증 파일의 `theme` 필드를 사용하도록 변경해야 함.

---

## 추후 고려 가능한 확장

- 관리자 권한 (다른 사람 코멘트 삭제 가능)
- 비밀번호 복잡성 요구사항
- 웹 뷰어 로그인 지원
- 로그인 히스토리/로그
- 비밀번호 찾기/초기화 기능

**현재 요구사항에서는 불필요하므로 구현하지 않음**

---

## 요약: 다음 세션에서 참고할 핵심 사항

### 1. 왜 이 기능이 필요한가?
- 다른 사람 이름으로 코멘트 작성/수정/삭제 방지
- 팀원 인증 (특정 이름에 비밀번호 설정)

### 2. 핵심 설계 결정
- **인증 파일 위치**: exe 옆 (Google Drive로 자동 공유)
- **비보호 사용자**: 등록 안 된 이름은 자유 사용 (본인 코멘트만 수정/삭제)
- **로그아웃**: 별도 버튼 없음, "이름 변경" = 로그아웃 + 새 로그인
- **resolved 상태**: 아무나 변경 가능 (리뷰어 편의)
- **동시 수정 충돌**: 단순 처리 (나중에 저장한 사람이 이김)

### 3. 세 가지 환경
- 개발 (`npm run dev`): 프로젝트 루트에 인증 파일
- 개발 빌드 (`dist/win-unpacked/`): exe 옆에 인증 파일
- 배포 (G드라이브): exe 옆에 인증 파일 (팀 공유)

### 4. 구현 순서
```
Phase 1: IPC 핸들러 → Phase 2: AuthManager → Phase 3: user-settings 연동
→ Phase 4: UI → Phase 5: 권한 체크 → Phase 6: 테스트
```

### 5. 주의 사항
- 기존 `user-settings.js`의 테마 하드코딩 → 인증 파일의 theme 필드로 대체 필요
- 답글(replies)도 본인만 수정/삭제 가능하도록 권한 체크 필요
- 인증 파일 없으면 비보호 모드로 동작 (경고 표시)
